<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantumHarmony Notarial Service</title>
    <!-- SHA3/Keccak-256 for AccountId derivation (PQC), Blake2b for SS58 checksum -->
    <script src="https://cdn.jsdelivr.net/npm/js-sha3@0.9.3/src/sha3.min.js"></script>
    <script src="js/blakejs-browser.js"></script>
    <script src="js/keystore.js"></script>
    <script src="js/ipfs.js"></script>
    <!-- EmailJS for browser-side credential email delivery -->
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Antonio:wght@400;700&family=Inter:wght@400;500;600&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            /* Professional notarial color palette */
            --primary: #4a5568;        /* Slate gray */
            --primary-light: #718096;  /* Light slate */
            --accent: #c9a227;         /* Muted gold */
            --accent-light: #d4b84a;   /* Light gold */
            --navy: #1a365d;           /* Deep navy */
            --navy-light: #2c5282;     /* Light navy */
            --bg: #0d1117;             /* Near black */
            --card: #161b22;           /* Dark card */
            --text: #e6edf3;           /* Light text */
            --muted: #8b949e;          /* Muted text */
            --success: #238636;        /* Green */
            --warning: #9e6a03;        /* Amber */
            --error: #da3633;          /* Red */
            --border: #30363d;         /* Border */
        }

        /* ===========================================
           TOAST NOTIFICATIONS
           =========================================== */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: var(--card);
            border-left: 4px solid var(--accent);
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            max-width: 400px;
            animation: toastSlideIn 0.3s ease-out;
            pointer-events: auto;
            border: 1px solid var(--border);
        }

        .toast.success { border-left-color: var(--success); }
        .toast.error { border-left-color: var(--error); }
        .toast.warning { border-left-color: var(--warning); }

        .toast-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
            color: #fff;
        }

        .toast.success .toast-icon { background: var(--success); }
        .toast.error .toast-icon { background: var(--error); }
        .toast.warning .toast-icon { background: var(--warning); }
        .toast.info .toast-icon { background: var(--accent); }

        .toast-content { flex: 1; }
        .toast-title { font-weight: 600; font-size: 14px; color: var(--text); }
        .toast-message { font-size: 12px; color: var(--muted); margin-top: 2px; }

        .toast-close {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            padding: 4px;
            font-size: 18px;
            line-height: 1;
        }

        .toast-close:hover { color: var(--text); }

        @keyframes toastSlideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.hiding { animation: toastSlideOut 0.3s ease-in forwards; }

        @keyframes toastSlideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* ===========================================
           LOADING STATES
           =========================================== */
        .btn-loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin: -8px 0 0 -8px;
            border: 2px solid #fff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: btnSpin 0.8s linear infinite;
        }

        @keyframes btnSpin {
            to { transform: rotate(360deg); }
        }

        /* ===========================================
           OFFLINE BANNER
           =========================================== */
        .offline-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--error);
            color: white;
            text-align: center;
            padding: 10px;
            font-weight: 600;
            z-index: 10001;
            display: none;
        }

        .offline-banner.visible { display: block; }

        /* ===========================================
           FORM VALIDATION
           =========================================== */
        input.invalid, textarea.invalid, select.invalid {
            border-color: var(--error) !important;
            box-shadow: 0 0 0 2px rgba(218, 54, 51, 0.2);
        }

        input.valid, textarea.valid, select.valid {
            border-color: var(--success) !important;
        }

        .form-error {
            color: var(--error);
            font-size: 11px;
            margin-top: 4px;
        }

        /* ===========================================
           RESPONSIVE IMPROVEMENTS
           =========================================== */
        @media (max-width: 768px) {
            .lcars-sidebar { display: none; }
            .main-content { margin-left: 0 !important; }
            .toast { min-width: 280px; max-width: calc(100vw - 40px); }
            .lcars-elbow-top-left { width: 60px; }
            .lcars-elbow-top-left span { display: none; }
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow-x: hidden;
            min-height: 100vh;
            line-height: 1.6;
        }

        /* LCARS Frame */
        .lcars-frame {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Top Bar */
        .lcars-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 70px;
            display: flex;
            gap: 8px;
            padding: 8px;
        }

        .lcars-elbow-top-left {
            width: 180px;
            height: 54px;
            background: linear-gradient(135deg, var(--navy), var(--navy-light));
            border-radius: 0 0 30px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            pointer-events: all;
            border: 1px solid var(--border);
        }

        .lcars-bar-segment {
            flex: 1;
            height: 36px;
            background: linear-gradient(90deg, var(--primary), var(--primary-light));
            border-radius: 18px;
            margin-top: 9px;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-family: 'Antonio', sans-serif;
            font-size: 16px;
            font-weight: bold;
            color: var(--text);
            letter-spacing: 1px;
            border: 1px solid var(--border);
        }

        .lcars-elbow-top-right {
            width: 200px;
            height: 54px;
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            border-radius: 0 0 0 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            pointer-events: all;
            border: 1px solid var(--border);
        }

        .lcars-button {
            padding: 8px 14px;
            background: var(--card);
            border-radius: 12px;
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 12px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s;
        }

        .lcars-button:hover {
            background: var(--primary);
            border-color: var(--primary-light);
        }

        .lcars-button.success {
            background: var(--success);
            border-color: var(--success);
        }

        .lcars-button.warning {
            background: var(--warning);
            border-color: var(--warning);
            color: #000;
        }

        /* Left Sidebar */
        .lcars-sidebar {
            position: absolute;
            left: 8px;
            top: 78px;
            bottom: 88px;
            width: 170px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .lcars-panel {
            background: var(--primary);
            border-radius: 16px;
            padding: 14px;
            color: var(--text);
            font-family: 'Antonio', sans-serif;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s;
            border: 1px solid var(--border);
            text-align: center;
            letter-spacing: 0.5px;
        }

        .lcars-panel:hover {
            background: var(--primary-light);
        }

        .lcars-panel.active {
            background: var(--accent);
            color: #000;
            border-color: var(--accent-light);
        }

        .lcars-panel-tall {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--navy);
            border: 1px solid var(--border);
            font-size: 11px;
            color: var(--muted);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            letter-spacing: 2px;
            font-family: 'Antonio', sans-serif;
        }

        /* Bottom Bar */
        .lcars-bottom {
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            height: 72px;
            display: flex;
            gap: 8px;
        }

        .lcars-status-panel {
            width: 170px;
            background: var(--primary);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--text);
            font-family: 'Antonio', sans-serif;
            border: 1px solid var(--border);
        }

        .lcars-status-bar {
            flex: 1;
            background: var(--navy);
            border-radius: 16px;
            display: flex;
            align-items: center;
            padding: 0 20px;
            color: var(--muted);
            font-size: 13px;
            border: 1px solid var(--border);
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            margin-right: 12px;
            animation: pulse 3s infinite;
        }

        .status-indicator.disconnected {
            background: var(--error);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Main Content */
        .lcars-content {
            position: absolute;
            left: 194px;
            top: 86px;
            right: 16px;
            bottom: 88px;
            overflow-y: auto;
            padding: 16px;
            pointer-events: all;
        }

        .lcars-display {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 16px;
        }

        .lcars-title {
            font-family: 'Antonio', sans-serif;
            font-size: 22px;
            color: var(--accent);
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .lcars-subtitle {
            font-size: 14px;
            color: var(--muted);
            margin-bottom: 20px;
        }

        .section { display: none; }
        .section.active { display: block; }

        /* Explanation boxes */
        .info-box {
            background: rgba(26, 54, 93, 0.3);
            border: 1px solid var(--navy-light);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            font-size: 14px;
            line-height: 1.7;
        }

        .info-box h4 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
        }

        .info-box p {
            color: var(--muted);
            margin-bottom: 8px;
        }

        .info-box p:last-child {
            margin-bottom: 0;
        }

        .info-box ul {
            margin: 8px 0 8px 20px;
            color: var(--muted);
        }

        .info-box li {
            margin: 4px 0;
        }

        .step-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--accent);
            color: #000;
            border-radius: 50%;
            font-weight: bold;
            font-size: 12px;
            margin-right: 8px;
        }

        .warning-box {
            background: rgba(158, 106, 3, 0.15);
            border: 1px solid var(--warning);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            font-size: 14px;
        }

        .warning-box h4 {
            color: var(--warning);
            margin-bottom: 8px;
        }

        /* Data Fields */
        .data-field {
            margin: 16px 0;
        }

        .data-label {
            color: var(--muted);
            font-size: 12px;
            margin-bottom: 6px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-value {
            color: var(--text);
            font-size: 14px;
            word-break: break-all;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        input, textarea, select {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 12px;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent);
        }

        input::placeholder, textarea::placeholder {
            color: var(--muted);
        }

        select option {
            background: var(--bg);
            color: var(--text);
        }

        .action-button {
            background: var(--accent);
            border: none;
            color: #000;
            padding: 12px 24px;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin: 8px 4px 8px 0;
            transition: all 0.2s;
        }

        .action-button:hover {
            background: var(--accent-light);
            transform: translateY(-1px);
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .action-button.secondary {
            background: var(--primary);
            color: var(--text);
        }

        .action-button.secondary:hover {
            background: var(--primary-light);
        }

        /* File Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s;
            margin: 16px 0;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(201, 162, 39, 0.05);
        }

        .drop-zone-icon {
            font-size: 40px;
            margin-bottom: 12px;
            opacity: 0.7;
        }

        .drop-zone-text {
            color: var(--muted);
            font-size: 14px;
        }

        .drop-zone-hint {
            color: var(--muted);
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.7;
        }

        /* Results */
        .result-box {
            padding: 16px;
            border-radius: 8px;
            margin: 16px 0;
            display: none;
            font-size: 14px;
        }

        .result-box.success {
            background: rgba(35, 134, 54, 0.15);
            border: 1px solid var(--success);
            color: #3fb950;
            display: block;
        }

        .result-box.error {
            background: rgba(218, 54, 51, 0.15);
            border: 1px solid var(--error);
            color: #f85149;
            display: block;
        }

        /* Contract Cards */
        .contract-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }

        .contract-card {
            background: var(--bg);
            border-radius: 8px;
            padding: 20px;
            border: 1px solid var(--border);
            transition: all 0.2s;
        }

        .contract-card:hover {
            border-color: var(--accent);
        }

        .contract-card h3 {
            font-size: 16px;
            margin-bottom: 8px;
            color: var(--text);
        }

        .contract-card .meta {
            font-size: 12px;
            color: var(--muted);
            margin: 8px 0;
        }

        .contract-card .status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .contract-card .status.draft { background: var(--warning); color: #000; }
        .contract-card .status.active { background: var(--navy-light); color: var(--text); }
        .contract-card .status.executed { background: var(--success); color: var(--text); }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 520px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .modal-title {
            font-family: 'Antonio', sans-serif;
            font-size: 20px;
            color: var(--accent);
            margin-bottom: 16px;
            letter-spacing: 0.5px;
        }

        /* Logo */
        .logo-svg {
            width: 36px;
            height: 30px;
        }

        .logo-text {
            font-family: 'Antonio', sans-serif;
            font-size: 14px;
            color: var(--text);
            letter-spacing: 1px;
        }

        /* History List */
        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        /* Help text */
        .help-text {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        /* Divider */
        hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 24px 0;
        }

        /* Feature list */
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin: 16px 0;
        }

        .feature-item {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            font-size: 13px;
        }

        .feature-item strong {
            color: var(--accent);
            display: block;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <!-- Offline Banner -->
    <div class="offline-banner" id="offlineBanner">
        Connection lost. Reconnecting...
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="lcars-frame">
        <!-- Top Bar -->
        <div class="lcars-top">
            <div class="lcars-elbow-top-left">
                <svg class="logo-svg" viewBox="0 0 100 80" fill="var(--text)">
                    <circle cx="15" cy="18" r="10"/>
                    <circle cx="15" cy="42" r="10"/>
                    <circle cx="15" cy="66" r="10"/>
                    <circle cx="62" cy="42" r="28" fill="none" stroke="var(--text)" stroke-width="10"/>
                    <circle cx="78" cy="42" r="8"/>
                </svg>
                <span class="logo-text">NOTARIAL</span>
            </div>
            <div class="lcars-bar-segment">QUANTUMHARMONY NOTARIAL SERVICE</div>
            <div class="lcars-elbow-top-right">
                <button class="lcars-button" id="langToggle" onclick="toggleLanguage()" style="min-width: 45px;">EN</button>
                <button class="lcars-button" id="accountStatusBtn" onclick="showAccountModal()">
                    <span id="accountStatusText">NO ACCOUNT</span>
                </button>
            </div>
        </div>

        <!-- Left Sidebar -->
        <div class="lcars-sidebar">
            <div class="lcars-panel active" data-section="start" onclick="showSection('start', this)" data-i18n="nav.start">START</div>
            <div class="lcars-panel" data-section="attest" onclick="showSection('attest', this)" data-i18n="nav.attest">ATTEST</div>
            <div class="lcars-panel" data-section="verify" onclick="showSection('verify', this)" data-i18n="nav.verify">VERIFY</div>
            <div class="lcars-panel" data-section="contracts" onclick="showSection('contracts', this)" data-i18n="nav.contracts">CONTRACTS</div>
            <div class="lcars-panel" data-section="qcad" onclick="showSection('qcad', this)" data-i18n="nav.qcad">QCAD</div>
            <div class="lcars-panel" data-section="trust" onclick="showSection('trust', this)" data-i18n="nav.trust">TRUST</div>
            <div class="lcars-panel" data-section="account" onclick="showSection('account', this)" data-i18n="nav.account">ACCOUNT</div>
            
            <div class="lcars-panel" data-section="settings" onclick="showSection('settings', this)" data-i18n="nav.settings">SETTINGS</div>
            <div class="lcars-panel" data-section="proofs" onclick="showSection('proofs', this)" data-i18n="nav.proofs">PROOFS</div>
        </div>

        <!-- Bottom Bar -->
        <div class="lcars-bottom">
            <div class="lcars-status-panel">
                <div style="font-size: 10px; color: var(--muted);">BLOCKCHAIN</div>
                <div id="nodeStatus" style="font-size: 14px;">CONNECTING</div>
            </div>
            <div class="lcars-status-bar">
                <div class="status-indicator disconnected" id="statusIndicator"></div>
                <span>Endpoint: <span id="rpcEndpoint">--</span> | <span class="transport-badge" id="transportBadge" style="display:inline-block;padding:1px 8px;border-radius:4px;font-size:11px;font-weight:bold;letter-spacing:1px;background:#555;color:#fff;">DETECTING</span> | SPHINCS+ Signatures | SHA-256 Document Hashing</span>
            </div>
            <div class="lcars-status-panel">
                <div style="font-size: 10px; color: var(--muted);">TIME (UTC)</div>
                <div id="currentTime" style="font-size: 14px;">00:00:00</div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="lcars-content">

        <!-- ==================== START / GETTING STARTED SECTION ==================== -->
        <div id="section-start" class="section active">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="start.title">Getting Started</div>
                <div class="lcars-subtitle" data-i18n="start.subtitle">Welcome to QuantumHarmony - Your journey to post-quantum secure notarial services</div>

                <div class="info-box">
                    <h4 data-i18n="start.welcome.title">Welcome to QuantumHarmony</h4>
                    <p data-i18n="start.welcome.p1">QuantumHarmony is the first post-quantum secure blockchain designed for notarial and legal applications. All transactions are protected by SPHINCS+ signatures, which are resistant to attacks from future quantum computers.</p>

                    <h4 style="margin-top: 16px;" data-i18n="start.steps.title">Quick Start Steps</h4>
                    <ol style="margin: 8px 0 8px 20px; color: var(--muted);">
                        <li data-i18n="start.quickstep.1"><strong>Step 1:</strong> Create your account below (or import existing key)</li>
                        <li data-i18n="start.quickstep.2"><strong>Step 2:</strong> Fund your account with free testnet tokens</li>
                        <li data-i18n="start.quickstep.3"><strong>Step 3:</strong> Attest documents, create contracts, use QCAD</li>
                    </ol>
                </div>
            </div>

            <!-- STEP 1: CREATE ACCOUNT (FIRST!) -->
            <div class="lcars-display" id="startCreateAccount">
                <div class="lcars-title"><span style="background: var(--accent); color: #000; padding: 2px 8px; border-radius: 4px; margin-right: 8px;" data-i18n="start.step1.badge">STEP 1</span> <span data-i18n="start.step1.title">Create Your Account</span></div>
                <div class="lcars-subtitle" data-i18n="start.step1.subtitle">Your account is stored locally and secured with post-quantum cryptography</div>

                <div id="startNoAccount">
                    <div class="warning-box">
                        <h4 data-i18n="start.step1.noAccount.title">No Account Found</h4>
                        <p data-i18n="start.step1.noAccount.p1">You need an account to use QuantumHarmony. Create one now - it only takes a few seconds!</p>
                    </div>

                    <div class="data-field">
                        <div class="data-label" data-i18n="start.step1.name.label">Account Name</div>
                        <input type="text" id="startAccountName" placeholder="e.g., My Notary Account" value="My Account">
                        <div class="help-text" data-i18n="start.step1.name.help">A friendly name to identify your account</div>
                    </div>

                    <div class="data-field">
                        <div class="data-label" data-i18n="start.step1.password.label">Password</div>
                        <input type="password" id="startPassword" placeholder="Choose a strong password (min 8 chars)">
                        <div class="help-text" data-i18n="start.step1.password.help">This encrypts your private key. Don't forget it!</div>
                    </div>

                    <div class="data-field">
                        <div class="data-label" data-i18n="start.step1.confirm.label">Confirm Password</div>
                        <input type="password" id="startPasswordConfirm" placeholder="Re-enter your password">
                    </div>

                    <button class="action-button" onclick="createAccountFromStart()" style="font-size: 16px; padding: 14px 28px;" data-i18n="start.step1.button">Create Account</button>
                    <div class="result-box" id="startCreateResult"></div>
                </div>

                <div id="startHasAccount" style="display: none;">
                    <div class="info-box" style="background: rgba(35, 134, 54, 0.1); border-color: var(--success);">
                        <h4 style="color: var(--success);" data-i18n="start.step1.ready.title">‚úì Account Ready</h4>
                        <p><span data-i18n="start.step1.ready.account">Your account:</span> <strong id="startAccountAddress">-</strong></p>
                        <p style="margin-top: 8px;" data-i18n="start.step1.ready.proceed">Now proceed to Step 2 to fund your account.</p>
                    </div>
                </div>
            </div>

            <!-- STEP 2: FUND ACCOUNT -->
            <div class="lcars-display">
                <div class="lcars-title"><span style="background: var(--lcars-gold); color: #000; padding: 2px 8px; border-radius: 4px; margin-right: 8px;" data-i18n="start.step2.badge">STEP 2</span> <span data-i18n="start.step2.title">Fund Your Account</span></div>
                <div class="lcars-subtitle" data-i18n="start.step2.subtitle">Get free testnet tokens to start using the network</div>

                <div class="info-box">
                    <h4 data-i18n="start.faucet.what.title">What are QMHY Tokens?</h4>
                    <p data-i18n="start.step2.tokens.p1">QMHY tokens are needed to pay transaction fees. On testnet, they're free!</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="start.step2.address.label">Your Account Address</div>
                    <input type="text" id="faucetAddress" placeholder="Create account first (Step 1)" readonly style="background: rgba(0,0,0,0.3);">
                    <div class="help-text" data-i18n="start.step2.address.help">This will be auto-filled after you create an account</div>
                </div>

                <button class="action-button" onclick="requestFaucetFromStart()" id="startFaucetBtn" disabled data-i18n="start.step2.requestBtn">Request 100 QMHY Tokens</button>
                <button class="action-button secondary" onclick="checkBalance()" disabled id="startCheckBalanceBtn" data-i18n="start.faucet.checkBalance">Check Balance</button>

                <div class="result-box" id="faucetResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="start.network.title">Network Information</div>
                <div class="lcars-subtitle" data-i18n="start.network.subtitle">Current testnet status and specifications</div>

                <div class="feature-list">
                    <div class="feature-item">
                        <strong data-i18n="start.network.token">Token Symbol</strong>
                        <span>QMHY</span>
                    </div>
                    <div class="feature-item">
                        <strong data-i18n="start.network.decimals">Decimals</strong>
                        <span>12</span>
                    </div>
                    <div class="feature-item">
                        <strong data-i18n="start.network.blockTime">Block Time</strong>
                        <span data-i18n="start.network.blockTime.val">~3 seconds</span>
                    </div>
                    <div class="feature-item">
                        <strong data-i18n="start.network.consensus">Consensus</strong>
                        <span data-i18n="start.network.consensus.val">Aura + Proof of Coherence</span>
                    </div>
                    <div class="feature-item">
                        <strong data-i18n="start.network.signatures">Signatures</strong>
                        <span data-i18n="start.network.signatures.val">SPHINCS+-256s (Post-Quantum)</span>
                    </div>
                    <div class="feature-item">
                        <strong data-i18n="start.network.validators">Active Validators</strong>
                        <span id="activeValidators">2</span>
                    </div>
                </div>

                <div class="info-box" style="margin-top: 16px;">
                    <h4 data-i18n="start.network.validators.title">Production Validators</h4>
                    <ul>
                        <li><strong>Alice</strong> - Montr√©al, Canada (51.79.26.123)</li>
                        <li><strong>Bob</strong> - Beauharnois, Canada (51.79.26.168)</li>
                        <li><strong>Charlie</strong> - <span data-i18n="start.network.frankfurt">Frankfurt</span>, <span data-i18n="start.network.germany">Germany</span> (209.38.225.4)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ==================== ATTEST SECTION ==================== -->
        <div id="section-attest" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="attest.title">Document Attestation</div>
                <div class="lcars-subtitle" data-i18n="attest.subtitle">Create an immutable, timestamped proof that your document existed at a specific point in time</div>

                <div class="info-box">
                    <h4 data-i18n="attest.what.title">What is Document Attestation?</h4>
                    <p data-i18n="attest.what.p1">Document attestation creates a permanent, tamper-proof record on the QuantumHarmony blockchain proving that your document existed at a specific moment in time. This can be used for:</p>
                    <ul>
                        <li data-i18n="attest.what.li1"><strong>Intellectual Property</strong> - Prove when you created original work</li>
                        <li data-i18n="attest.what.li2"><strong>Legal Documents</strong> - Timestamp contracts, agreements, and legal filings</li>
                        <li data-i18n="attest.what.li3"><strong>Academic Records</strong> - Certify credentials and transcripts</li>
                        <li data-i18n="attest.what.li4"><strong>Compliance</strong> - Meet regulatory timestamp requirements</li>
                    </ul>
                    <p data-i18n="attest.what.privacy"><strong>Privacy Guarantee:</strong> Your document never leaves your browser. Only a cryptographic hash (digital fingerprint) is stored on the blockchain - the actual content remains completely private.</p>
                </div>

                <div class="warning-box" id="attestAccountWarning">
                    <h4 data-i18n="attest.warning.title">Account Required</h4>
                    <p data-i18n="attest.warning.p1">Before you can attest documents, you need to create and unlock an account. Go to the <strong>ACCOUNT</strong> section in the sidebar to create a secure keystore.</p>
                </div>

                <div class="lcars-title" style="font-size: 16px; margin-top: 24px;"><span class="step-indicator">1</span> <span data-i18n="attest.step1">Select Your Document</span></div>

                <div class="drop-zone" id="attestDropZone">
                    <div class="drop-zone-icon">üìÑ</div>
                    <div class="drop-zone-text" data-i18n="attest.dropzone.text">Drag and drop your document here, or click to browse</div>
                    <div class="drop-zone-hint" data-i18n="attest.dropzone.hint">Supported: Any file type (PDF, DOCX, images, etc.) up to 100MB</div>
                    <input type="file" id="attestFile" style="display: none;">
                </div>

                <div id="attestFileInfo" style="display: none;">
                    <div class="data-field">
                        <div class="data-label" data-i18n="attest.file.label">Selected Document</div>
                        <div class="data-value" id="attestFileName">--</div>
                        <div class="help-text" data-i18n="attest.file.help">This is the file you've selected for attestation</div>
                    </div>
                    <div class="data-field">
                        <div class="data-label" data-i18n="attest.hash.label">Document Hash (SHA-256)</div>
                        <div class="data-value" id="attestFileHash">--</div>
                        <div class="help-text" data-i18n="attest.hash.help">This unique fingerprint identifies your document. Only this hash will be stored on-chain - your file content stays private.</div>
                    </div>
                </div>

                <div class="lcars-title" style="font-size: 16px; margin-top: 24px;"><span class="step-indicator">2</span> <span data-i18n="attest.step2">Choose Document Category</span></div>

                <div class="data-field">
                    <div class="data-label" data-i18n="attest.category.label">Category</div>
                    <select id="attestCategory">
                        <option value="0" data-i18n="attest.category.0">Academic Credential - Diplomas, certificates, transcripts</option>
                        <option value="1" data-i18n="attest.category.1">Legal Document - Contracts, agreements, court filings</option>
                        <option value="2" data-i18n="attest.category.2">Contract - Business agreements, service contracts</option>
                        <option value="3" data-i18n="attest.category.3">Intellectual Property - Patents, designs, creative works</option>
                        <option value="4" data-i18n="attest.category.4">Identity Document - ID verification, KYC documents</option>
                        <option value="5" data-i18n="attest.category.5">Financial Record - Invoices, receipts, statements</option>
                        <option value="6" data-i18n="attest.category.6">Medical Record - Health records, prescriptions</option>
                        <option value="7" data-i18n="attest.category.7">Other - General purpose attestation</option>
                    </select>
                    <div class="help-text" data-i18n="attest.category.help">Categorizing your document helps with organization and searchability</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="attest.desc.label">Description (Optional)</div>
                    <input type="text" id="attestDescription" placeholder="Brief description of the document" maxlength="256">
                    <div class="help-text" data-i18n="attest.desc.help">A short description stored on-chain with your attestation (max 256 characters)</div>
                </div>

                <div class="lcars-title" style="font-size: 16px; margin-top: 24px;"><span class="step-indicator">3</span> <span data-i18n="attest.step3">Storage Options (Optional)</span></div>

                <div class="data-field">
                    <div class="data-label" data-i18n="attest.storage.label">Document Storage</div>
                    <select id="storageOption">
                        <option value="local" data-i18n="attest.storage.local">Local Only - Hash stored on blockchain, document stays on your device</option>
                        <option value="ipfs" data-i18n="attest.storage.ipfs">IPFS Public - Document stored on decentralized network (publicly accessible)</option>
                        <option value="ipfs-encrypted" data-i18n="attest.storage.encrypted">IPFS Encrypted - Document encrypted before storage (private, requires key to access)</option>
                    </select>
                    <div class="help-text" data-i18n="attest.storage.help">Choose where your document file is stored. "Local Only" is the most private option - only the hash goes on-chain.</div>
                </div>

                <div class="info-box" id="ipfsConfigHint" style="display: none;">
                    <h4 data-i18n="attest.ipfs.title">IPFS Configuration Required</h4>
                    <p data-i18n="attest.ipfs.p1">To use IPFS storage, you need to configure your Pinata API keys in the <strong>SETTINGS</strong> section. Pinata provides reliable, permanent storage on the IPFS network.</p>
                </div>

                <div class="lcars-title" style="font-size: 16px; margin-top: 24px;"><span class="step-indicator">4</span> <span data-i18n="attest.step4">Submit Attestation</span></div>

                <div class="info-box">
                    <p data-i18n="attest.submit.info">When you submit, your document's hash will be permanently recorded on the QuantumHarmony blockchain with a SPHINCS+ post-quantum signature. This creates legally admissible proof of existence.</p>
                </div>

                <button class="action-button" onclick="submitAttestation()" id="attestBtn" disabled data-i18n="attest.submit.button">Submit Attestation to Blockchain</button>

                <div class="result-box" id="attestResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="attest.history.title">Your Attestation History</div>
                <div class="lcars-subtitle" data-i18n="attest.history.subtitle">Documents you have previously attested</div>

                <div class="info-box">
                    <p data-i18n="attest.history.info">Your attestation history is stored locally in your browser. Each entry shows the document name, hash, and timestamp. You can use these hashes to verify documents later.</p>
                </div>

                <div class="history-list" id="attestationHistory">
                    <div style="color: var(--muted); padding: 20px; text-align: center;" data-i18n="attest.history.empty">No attestations yet. Attest your first document above.</div>
                </div>
            </div>
        </div>

        <!-- ==================== VERIFY SECTION ==================== -->
        <div id="section-verify" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="verify.title">Document Verification</div>
                <div class="lcars-subtitle" data-i18n="verify.subtitle">Check if a document has been attested on the blockchain and view its attestation details</div>

                <div class="info-box">
                    <h4 data-i18n="verify.how.title">How Verification Works</h4>
                    <p data-i18n="verify.how.p1">Document verification allows anyone to confirm that a specific document was attested at a particular time. This is useful for:</p>
                    <ul>
                        <li data-i18n="verify.how.li1"><strong>Authenticity</strong> - Confirm a document hasn't been modified</li>
                        <li data-i18n="verify.how.li2"><strong>Timestamp Proof</strong> - Verify when a document existed</li>
                        <li data-i18n="verify.how.li3"><strong>Legal Evidence</strong> - Use as proof in disputes</li>
                    </ul>
                    <p>Simply upload the document (or paste its hash) and the system will search the blockchain for matching attestation records.</p>
                </div>

                <div class="lcars-title" style="font-size: 16px; margin-top: 24px;" data-i18n="verify.upload.title">Option A: Upload Document to Verify</div>

                <div class="drop-zone" id="verifyDropZone">
                    <div class="drop-zone-icon">üîç</div>
                    <div class="drop-zone-text" data-i18n="verify.dropzone.text">Drop the document you want to verify</div>
                    <div class="drop-zone-hint" data-i18n="verify.dropzone.hint">The system will compute its hash and search for matching attestations</div>
                    <input type="file" id="verifyFile" style="display: none;">
                </div>

                <div class="lcars-title" style="font-size: 16px; margin-top: 24px;" data-i18n="verify.hash.label">Option B: Enter Hash Directly</div>

                <div class="data-field">
                    <div class="data-label">Document Hash</div>
                    <input type="text" id="verifyHash" placeholder="0x... (64 character hex string)">
                    <div class="help-text" data-i18n="verify.hash.help">If you already know the document hash, paste it here. Must start with 0x followed by 64 hex characters.</div>
                </div>

                <button class="action-button" onclick="verifyDocument()" data-i18n="verify.button">Search Blockchain for Attestation</button>

                <div class="result-box" id="verifyResult"></div>
            </div>
        </div>

        <!-- ==================== CONTRACTS SECTION ==================== -->
        <div id="section-contracts" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="contracts.title">Ricardian Contracts</div>
                <div class="lcars-subtitle" data-i18n="contracts.subtitle">Create and sign multi-party agreements with blockchain-backed signatures</div>

                <div class="info-box">
                    <h4 data-i18n="contracts.what.title">What are Ricardian Contracts?</h4>
                    <p data-i18n="contracts.what.p1">Ricardian contracts are legally binding agreements that exist both as human-readable documents and as cryptographically signed records on the blockchain. They combine the legal enforceability of traditional contracts with the immutability and transparency of blockchain technology.</p>

                    <h4 style="margin-top: 16px;">How It Works</h4>
                    <ul>
                        <li><strong>Create:</strong> Define the contract terms, add all parties, and submit to the blockchain</li>
                        <li><strong>Sign:</strong> Each party signs the contract with their SPHINCS+ key</li>
                        <li><strong>Execute:</strong> When all required parties have signed, the contract becomes fully executed</li>
                        <li><strong>Verify:</strong> Anyone can verify the contract and its signatures on-chain</li>
                    </ul>
                </div>

                <div class="warning-box" id="contractAccountWarning">
                    <h4 data-i18n="contracts.warning.title">Account Required</h4>
                    <p data-i18n="contracts.warning.p1">You need an unlocked account to create or sign contracts. Go to <strong>ACCOUNT</strong> to set up your keystore.</p>
                </div>

                <div class="feature-list">
                    <div class="feature-item">
                        <strong>Create Contract</strong>
                        Draft a new multi-party agreement with custom terms
                    </div>
                    <div class="feature-item">
                        <strong>Sign Contract</strong>
                        Add your cryptographic signature to a contract
                    </div>
                    <div class="feature-item">
                        <strong>View Contract</strong>
                        Look up contract details and signature status
                    </div>
                </div>

                <button class="action-button" onclick="showCreateContractModal()" data-i18n="contracts.create.button">Create New Contract</button>
                <button class="action-button secondary" onclick="showSignContractModal()" data-i18n="contracts.sign.button">Sign Existing Contract</button>
                <button class="action-button secondary" onclick="showViewContractModal()" data-i18n="contracts.view.button">View Contract Details</button>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="contracts.your.title">Your Contracts</div>
                <div class="lcars-subtitle" data-i18n="contracts.your.subtitle">Contracts you have created or are a party to</div>

                <div class="info-box">
                    <h4>Contract Status Guide</h4>
                    <ul>
                        <li><strong style="color: var(--warning);">DRAFT</strong> - Contract created but no signatures yet</li>
                        <li><strong style="color: var(--navy-light);">ACTIVE</strong> - Some parties have signed, waiting for others</li>
                        <li><strong style="color: var(--success);">EXECUTED</strong> - All required parties have signed</li>
                    </ul>
                </div>

                <div class="contract-grid" id="contractsGrid">
                    <div style="color: var(--muted); padding: 20px;" data-i18n="contracts.empty">No contracts yet. Create your first contract above.</div>
                </div>
            </div>
        </div>

        <!-- ==================== ACCOUNT SECTION ==================== -->
        <div id="section-account" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="account.title">Account Management</div>
                <div class="lcars-subtitle" data-i18n="account.subtitle">Create and manage your secure SPHINCS+ keystore for signing documents and contracts</div>

                <div class="info-box">
                    <h4 data-i18n="account.what.title">Understanding Your Keystore</h4>
                    <p data-i18n="account.what.p1">Your keystore contains a SPHINCS+ cryptographic key pair that is used to sign attestations and contracts. SPHINCS+ is a post-quantum signature algorithm, meaning it remains secure even against future quantum computer attacks.</p>

                    <h4 style="margin-top: 16px;">Security Model</h4>
                    <ul>
                        <li data-i18n="account.what.li1"><strong>Encrypted Storage:</strong> Your private key is encrypted with AES-256-GCM using your password</li>
                        <li data-i18n="account.what.li2"><strong>Key Derivation:</strong> PBKDF2 with 100,000 iterations protects against brute-force attacks</li>
                        <li data-i18n="account.what.li3"><strong>Local Only:</strong> Your keystore is stored in your browser - it never leaves your device</li>
                        <li><strong>Session Unlock:</strong> You unlock once per session for convenience, then re-lock when done</li>
                    </ul>

                    <p style="margin-top: 12px;" data-i18n="account.security.p1"><strong>Important:</strong> If you lose your password, there is no way to recover your keys. Store your password securely.</p>
                </div>

                <hr>

                <div class="lcars-title" style="font-size: 16px;" data-i18n="account.unlock.title">Select Existing Keystore</div>

                <div class="data-field">
                    <div class="data-label" data-i18n="account.select.label">Your Keystores</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="keystoreSelect" onchange="selectKeystore()" style="flex: 1;">
                            <option value="">-- Select a keystore to unlock --</option>
                        </select>
                        <button class="action-button secondary" onclick="deleteSelectedKeystore()" style="padding: 8px 16px; font-size: 12px;" title="Delete selected keystore" data-i18n="account.delete.button">Delete</button>
                        <button class="action-button" onclick="clearAllKeystores()" style="padding: 8px 12px; font-size: 12px; background: var(--error);" title="Clear all keystores" data-i18n="account.clearAll.button">Clear All</button>
                    </div>
                    <div class="help-text">Select one of your existing keystores to unlock it for signing</div>
                </div>

                <div id="keystoreUnlockSection" style="display: none;">
                    <div class="data-field">
                        <div class="data-label" data-i18n="account.unlockPassword.label">Keystore Password</div>
                        <input type="password" id="keystorePassword" placeholder="Enter your password">
                        <div class="help-text">Enter the password you set when creating this keystore</div>
                    </div>
                    <button class="action-button" onclick="unlockKeystore()" data-i18n="account.unlock.button">Unlock Keystore</button>
                </div>

                <div id="keystoreInfo" style="display: none;">
                    <div class="info-box" style="background: rgba(35, 134, 54, 0.1); border-color: var(--success);">
                        <h4 style="color: var(--success);">Keystore Unlocked</h4>
                        <p>Your keystore is now unlocked. You can sign attestations and contracts. Remember to lock your keystore when you're done for security.</p>
                    </div>

                    <div class="data-field">
                        <div class="data-label" data-i18n="account.pubkey.label">Your Public Key</div>
                        <div class="data-value" id="publicKeyDisplay">--</div>
                        <div class="help-text">This is your public identifier. Share this with others who need to verify your signatures or add you as a contract party.</div>
                    </div>

                    <button class="action-button secondary" onclick="lockKeystore()" data-i18n="account.lock.button">Lock Keystore</button>
                </div>

                <hr>

                <div class="lcars-title" style="font-size: 16px;">Quick Setup (Recommended for Testing)</div>

                <div class="info-box" style="background: rgba(201, 162, 39, 0.1); border-color: var(--accent);">
                    <h4 style="color: var(--accent);">Use Test Account</h4>
                    <p>For testing, you can use the pre-funded Alice validator account. This account has tokens and can immediately sign transactions.</p>
                </div>

                <div class="data-field">
                    <div class="data-label">Password for Alice Key</div>
                    <input type="password" id="aliceKeyPassword" placeholder="Choose a password to protect this key locally">
                    <div class="help-text">This password encrypts the key in your browser</div>
                </div>

                <button class="action-button" onclick="importAliceKey()">Import Alice Test Account</button>

                <hr>

                <div class="lcars-title" style="font-size: 16px;" data-i18n="account.create.title">Create New Keystore</div>

                <div class="info-box">
                    <p>Create a new SPHINCS+ key pair. <strong style="color: var(--warning);">Note:</strong> New accounts need to be funded before they can sign transactions. After creating, use the "Fund Account" button to receive tokens from the faucet.</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="account.name.label">Keystore Name</div>
                    <input type="text" id="newKeystoreName" placeholder="e.g., Personal, Work, Legal">
                    <div class="help-text" data-i18n="account.name.help">A friendly name to identify this keystore</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="account.password.label">Password</div>
                    <input type="password" id="newKeystorePassword" placeholder="Choose a strong password">
                    <div class="help-text" data-i18n="account.password.help">Use at least 12 characters with a mix of letters, numbers, and symbols</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="account.confirm.label">Confirm Password</div>
                    <input type="password" id="newKeystoreConfirm" placeholder="Re-enter your password">
                    <div class="help-text">Make sure both passwords match</div>
                </div>

                <button class="action-button" onclick="createNewKeystore()" data-i18n="account.create.button">Create New Keystore</button>

                <hr>

                <div class="lcars-title" style="font-size: 16px;">Import Existing Key</div>

                <div class="info-box">
                    <p>Import an existing SPHINCS+ secret key (128 bytes hex-encoded). This is for validators or users who already have a funded account on the blockchain.</p>
                    <p style="margin-top: 8px; color: var(--warning);"><strong>Warning:</strong> Never share your secret key with anyone. This key controls your on-chain identity.</p>
                </div>

                <div class="data-field">
                    <div class="data-label">Keystore Name</div>
                    <input type="text" id="importKeystoreName" placeholder="e.g., Validator Key, Production">
                    <div class="help-text">A friendly name to identify this imported keystore</div>
                </div>

                <div class="data-field">
                    <div class="data-label">Secret Key (128 bytes hex)</div>
                    <input type="password" id="importSecretKey" placeholder="0x... (256 hex characters)">
                    <div class="help-text">Your SPHINCS+ secret key from your validator config</div>
                </div>

                <div class="data-field">
                    <div class="data-label">Password</div>
                    <input type="password" id="importKeystorePassword" placeholder="Choose a password to encrypt this key">
                    <div class="help-text">This password will encrypt the imported key for local storage</div>
                </div>

                <button class="action-button" onclick="importSecretKey()">Import Key</button>

                <hr>

                <div class="lcars-title" style="font-size: 16px;">Fund Account (Testnet Faucet)</div>

                <div class="info-box">
                    <p>Request free test tokens from the faucet. Each request sends <strong>100 QMHY</strong> to your account. This only works on testnet.</p>
                </div>

                <div id="fundAccountSection">
                    <div class="data-field">
                        <div class="data-label">Your Account Address</div>
                        <div class="data-value" id="fundAddressDisplay" style="font-size: 11px; word-break: break-all;">Unlock a keystore to see your address</div>
                    </div>
                    <button class="action-button" onclick="requestFaucetAccount()" id="faucetBtn" disabled>Request 100 QMHY</button>
                </div>

                <hr>

                <div class="lcars-title" style="font-size: 16px;" data-i18n="account.transfer.title">Transfer Tokens</div>

                <div class="info-box">
                    <p>Send tokens to another account. You must have an unlocked keystore with sufficient balance.</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="account.recipient.label">Recipient Address</div>
                    <input type="text" id="transferRecipient" placeholder="5Gx... or 0x... address">
                    <div class="help-text">The SS58 or hex address of the recipient</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="account.transferAmount.label">Amount (QMHY)</div>
                    <input type="number" id="transferAmount" placeholder="10" min="0.000001" step="0.000001">
                    <div class="help-text" data-i18n="account.transferAmount.help">Amount of tokens to send (1 QMHY = 1,000,000,000,000 units)</div>
                </div>

                <button class="action-button" onclick="transferTokens()" id="transferBtn" disabled data-i18n="account.transfer.button">Send Tokens</button>

                <div class="result-box" id="accountResult"></div>
            </div>
        </div>

        <!-- ==================== QCAD STABLECOIN SECTION ==================== -->
        <div id="section-qcad" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="qcad.title">QCAD Stablecoin</div>
                <div class="lcars-subtitle" data-i18n="qcad.subtitle">Canadian Dollar-pegged stablecoin backed by QMHY collateral</div>

                <div class="info-box">
                    <h4 data-i18n="qcad.what.title">What is QCAD?</h4>
                    <p data-i18n="qcad.what.p1">QCAD is a decentralized stablecoin pegged 1:1 to the Canadian Dollar. It is backed by QMHY tokens locked in collateralized vaults at a minimum 150% ratio.</p>

                    <h4 style="margin-top: 16px;" data-i18n="qcad.how.title">How It Works</h4>
                    <ul>
                        <li data-i18n="qcad.how.li1"><strong>Open a Vault:</strong> Lock QMHY tokens as collateral to mint QCAD</li>
                        <li data-i18n="qcad.how.li2"><strong>Collateral Ratio:</strong> Minimum 150% - if you lock $1500 QMHY, you can mint up to 1000 QCAD</li>
                        <li data-i18n="qcad.how.li3"><strong>Liquidation:</strong> If your ratio falls below 120%, your vault can be liquidated</li>
                        <li data-i18n="qcad.how.li4"><strong>Stability Fee:</strong> 2% annual interest on minted QCAD</li>
                    </ul>

                    <h4 style="margin-top: 16px;" data-i18n="qcad.civil.title">Civil Law Compliance (Quebec)</h4>
                    <p data-i18n="qcad.civil.p1">QCAD is designed to comply with Quebec Civil Code provisions for electronic currency and smart contracts, making it suitable for notarial and legal applications.</p>
                </div>

                <div class="warning-box" id="qcadAccountWarning">
                    <h4 data-i18n="qcad.warning.title">Account Required</h4>
                    <p data-i18n="qcad.warning.p1">You need to unlock your keystore in the <strong>ACCOUNT</strong> section before using QCAD features.</p>
                </div>
            </div>

            <!-- PRICE REPORTER SELECTION -->
            <div class="lcars-display">
                <div class="lcars-title">Price Feed Reporters</div>
                <div class="lcars-subtitle">Select trusted oracles for QMHY/CAD price data</div>

                <div class="info-box">
                    <h4>Decentralized Price Oracles</h4>
                    <p>QCAD uses a multi-reporter oracle system. Price submissions are aggregated from trusted reporters and vetted by the validator set before being accepted on-chain.</p>
                    <ul style="margin-top: 8px;">
                        <li><strong>Minimum Reporters:</strong> 3 required for price update</li>
                        <li><strong>Staleness Limit:</strong> 100 blocks (~5 minutes)</li>
                        <li><strong>Deviation Threshold:</strong> Max 2% from median</li>
                    </ul>
                </div>

                <div class="data-field">
                    <div class="data-label">Active Price Reporters</div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 4px; padding: 12px; margin-top: 8px;">
                        <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 1px solid var(--accent);">
                                    <th style="text-align: left; padding: 4px;">Reporter</th>
                                    <th style="text-align: right; padding: 4px;">Last Price</th>
                                    <th style="text-align: right; padding: 4px;">Reputation</th>
                                    <th style="text-align: center; padding: 4px;">Status</th>
                                    <th style="text-align: center; padding: 4px;">Select</th>
                                </tr>
                            </thead>
                            <tbody id="reporterTable">
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--accent);">Bank of Canada Feed</span></td>
                                    <td style="text-align: right; padding: 6px 4px;">1.0000 CAD</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--success);">98.7%</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--success);">‚óè</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><input type="checkbox" checked id="reporter1"></td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--accent);">Chainlink CAD/USD</span></td>
                                    <td style="text-align: right; padding: 6px 4px;">1.0002 CAD</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--success);">97.2%</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--success);">‚óè</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><input type="checkbox" checked id="reporter2"></td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--accent);">Paraxiom Oracle</span></td>
                                    <td style="text-align: right; padding: 6px 4px;">0.9998 CAD</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--success);">99.1%</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--success);">‚óè</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><input type="checkbox" checked id="reporter3"></td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--muted);">CoinGecko API</span></td>
                                    <td style="text-align: right; padding: 6px 4px;">1.0015 CAD</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--warning);">82.4%</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--warning);">‚óè</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><input type="checkbox" id="reporter4"></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="help-text">Select at least 3 reporters. Median price will be used for collateral calculations.</div>
                </div>

                <div style="display: flex; gap: 16px; margin-top: 16px;">
                    <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 11px; color: var(--muted);">CURRENT MEDIAN PRICE</div>
                        <div style="font-size: 24px; color: var(--accent); font-weight: bold;" id="medianPrice">1.0000 CAD</div>
                    </div>
                    <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 11px; color: var(--muted);">LAST UPDATE</div>
                        <div style="font-size: 24px; color: var(--success);" id="priceLastUpdate">Block #1,234,567</div>
                    </div>
                    <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 11px; color: var(--muted);">PRICE FRESHNESS</div>
                        <div style="font-size: 24px; color: var(--success);" id="priceFreshness">FRESH</div>
                    </div>
                </div>

                <button class="action-button secondary" onclick="refreshPriceFeeds()" style="margin-top: 16px;">Refresh Price Feeds</button>
            </div>

            <!-- LOCAL PRIORITY QUEUE -->
            <div class="lcars-display">
                <div class="lcars-title">Local Priority Queue</div>
                <div class="lcars-subtitle">Pending transactions awaiting validator vetting</div>

                <div class="info-box">
                    <h4>Transaction Flow</h4>
                    <p>All QCAD transactions are first submitted to your local node's priority queue. The validator set then vetts and approves transactions before they are included in a block. This ensures:</p>
                    <ul style="margin-top: 8px;">
                        <li><strong>Front-running Protection:</strong> Transactions are ordered fairly by the validator set</li>
                        <li><strong>Price Manipulation Prevention:</strong> Oracle updates are cross-validated</li>
                        <li><strong>Consensus Safety:</strong> 2/3 validator approval required for sensitive operations</li>
                    </ul>
                </div>

                <div class="data-field">
                    <div class="data-label">Queue Status</div>
                    <div style="display: flex; gap: 12px; margin-top: 8px;">
                        <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 28px; color: var(--accent);" id="queuePending">0</div>
                            <div style="font-size: 10px; color: var(--muted);">PENDING</div>
                        </div>
                        <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 28px; color: var(--warning);" id="queueVetting">0</div>
                            <div style="font-size: 10px; color: var(--muted);">VETTING</div>
                        </div>
                        <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; text-align: center;">
                            <div style="font-size: 28px; color: var(--success);" id="queueApproved">0</div>
                            <div style="font-size: 10px; color: var(--muted);">APPROVED</div>
                        </div>
                    </div>
                </div>

                <div class="data-field">
                    <div class="data-label">Your Pending Transactions</div>
                    <div id="pendingTxList" style="background: rgba(0,0,0,0.3); border-radius: 4px; padding: 12px; margin-top: 8px; max-height: 200px; overflow-y: auto;">
                        <div style="color: var(--muted); text-align: center; padding: 20px;">No pending transactions</div>
                    </div>
                </div>
            </div>

            <!-- VALIDATOR SET VETTING -->
            <div class="lcars-display">
                <div class="lcars-title">Validator Set Vetting</div>
                <div class="lcars-subtitle">Real-time consensus status for QCAD operations</div>

                <div class="info-box">
                    <h4>Threshold Requirements</h4>
                    <p>Different operations require different approval thresholds from the active validator set:</p>
                    <table style="width: 100%; margin-top: 12px; font-size: 12px;">
                        <tr style="border-bottom: 1px solid var(--accent);">
                            <td style="padding: 6px;"><strong>Standard Transfers</strong></td>
                            <td style="padding: 6px; text-align: right;">1/3 validators (fast path)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--accent);">
                            <td style="padding: 6px;"><strong>Vault Operations</strong></td>
                            <td style="padding: 6px; text-align: right;">1/2 validators</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--accent);">
                            <td style="padding: 6px;"><strong>Oracle Price Updates</strong></td>
                            <td style="padding: 6px; text-align: right;">2/3 validators</td>
                        </tr>
                        <tr>
                            <td style="padding: 6px;"><strong>Liquidations</strong></td>
                            <td style="padding: 6px; text-align: right;">2/3 validators</td>
                        </tr>
                    </table>
                </div>

                <div class="data-field">
                    <div class="data-label">Active Validator Set</div>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 4px; padding: 12px; margin-top: 8px;">
                        <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 1px solid var(--accent);">
                                    <th style="text-align: left; padding: 4px;">Validator</th>
                                    <th style="text-align: center; padding: 4px;">Status</th>
                                    <th style="text-align: right; padding: 4px;">Stake</th>
                                    <th style="text-align: right; padding: 4px;">Uptime</th>
                                </tr>
                            </thead>
                            <tbody id="validatorTable">
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--accent);">Alice (v1.quantumharmony.network)</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--success);">‚óè</span> Online</td>
                                    <td style="text-align: right; padding: 6px 4px;">10,000 QMHY</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--success);">99.9%</span></td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--accent);">Bob (v2.quantumharmony.network)</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--success);">‚óè</span> Online</td>
                                    <td style="text-align: right; padding: 6px 4px;">10,000 QMHY</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--success);">99.8%</span></td>
                                </tr>
                                <tr>
                                    <td style="padding: 6px 4px;"><span style="color: var(--accent);">Charlie (v3.quantumharmony.network)</span></td>
                                    <td style="text-align: center; padding: 6px 4px;"><span style="color: var(--success);">‚óè</span> Online</td>
                                    <td style="text-align: right; padding: 6px 4px;">10,000 QMHY</td>
                                    <td style="text-align: right; padding: 6px 4px;"><span style="color: var(--success);">99.7%</span></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div style="display: flex; gap: 16px; margin-top: 16px;">
                    <div style="flex: 1; background: rgba(35, 134, 54, 0.1); border: 1px solid var(--success); padding: 12px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 11px; color: var(--muted);">CONSENSUS STATUS</div>
                        <div style="font-size: 18px; color: var(--success); font-weight: bold;">HEALTHY</div>
                        <div style="font-size: 10px; color: var(--muted); margin-top: 4px;">3/3 validators online</div>
                    </div>
                    <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 11px; color: var(--muted);">CURRENT BLOCK</div>
                        <div style="font-size: 18px; color: var(--accent);" id="currentBlock">#1,234,567</div>
                        <div style="font-size: 10px; color: var(--muted); margin-top: 4px;">Finalized</div>
                    </div>
                    <div style="flex: 1; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; text-align: center;">
                        <div style="font-size: 11px; color: var(--muted);">AVG BLOCK TIME</div>
                        <div style="font-size: 18px; color: var(--accent);">3.0s</div>
                        <div style="font-size: 10px; color: var(--muted); margin-top: 4px;">Target: 3s</div>
                    </div>
                </div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="qcad.open.title">Open New Vault</div>
                <div class="lcars-subtitle" data-i18n="qcad.open.subtitle">Lock QMHY collateral to mint QCAD stablecoin</div>

                <div class="info-box">
                    <h4 data-i18n="qcad.open.info.title">Creating a Vault</h4>
                    <p data-i18n="qcad.open.info.p1">To open a vault, you deposit QMHY tokens as collateral and specify how much QCAD you want to mint. The collateral ratio must be at least 150%.</p>
                    <p style="margin-top: 8px;" data-i18n="qcad.open.info.example"><strong>Example:</strong> To mint 1,000 QCAD, you need at least 1,500 CAD worth of QMHY collateral.</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.collateral.label">QMHY Collateral Amount</div>
                    <input type="number" id="vaultCollateral" placeholder="Amount of QMHY to lock as collateral" min="0" step="0.000001">
                    <div class="help-text" data-i18n="qcad.collateral.help">QMHY tokens to lock (1 QMHY = 1,000,000,000,000 units)</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.mint.label">QCAD to Mint</div>
                    <input type="number" id="vaultDebt" placeholder="Amount of QCAD to mint" min="0" step="0.01">
                    <div class="help-text" data-i18n="qcad.mint.help">QCAD stablecoin to receive (minimum 100 QCAD per vault)</div>
                </div>

                <button class="action-button" onclick="openVault()" id="openVaultBtn" disabled data-i18n="qcad.open.button">Open Vault</button>
                <div class="result-box" id="openVaultResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="qcad.manage.title">Manage Existing Vault</div>
                <div class="lcars-subtitle" data-i18n="qcad.manage.subtitle">Deposit, withdraw, mint more, or repay debt on your vault</div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.vaultId.label">Vault ID</div>
                    <input type="number" id="manageVaultId" placeholder="Enter your vault ID" min="0">
                    <div class="help-text" data-i18n="qcad.vaultId.help">The ID of the vault you want to manage</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.amount.label">Amount</div>
                    <input type="number" id="vaultAmount" placeholder="Amount for the operation" min="0" step="0.000001">
                    <div class="help-text" data-i18n="qcad.amount.help">Amount in QMHY (for deposit/withdraw) or QCAD (for mint/repay)</div>
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px;">
                    <button class="action-button" onclick="depositCollateral()" id="depositCollateralBtn" disabled data-i18n="qcad.deposit.button">Deposit QMHY</button>
                    <button class="action-button secondary" onclick="withdrawCollateral()" id="withdrawCollateralBtn" disabled data-i18n="qcad.withdraw.button">Withdraw QMHY</button>
                    <button class="action-button" onclick="mintMoreQcad()" id="mintMoreBtn" disabled data-i18n="qcad.mintMore.button">Mint QCAD</button>
                    <button class="action-button secondary" onclick="repayQcad()" id="repayBtn" disabled data-i18n="qcad.repay.button">Repay QCAD</button>
                    <button class="action-button secondary" onclick="closeVault()" id="closeVaultBtn" disabled data-i18n="qcad.close.button">Close Vault</button>
                </div>

                <div class="result-box" id="manageVaultResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="qcad.transfer.title">Transfer QCAD</div>
                <div class="lcars-subtitle" data-i18n="qcad.transfer.subtitle">Send QCAD stablecoin to another account</div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.recipient.label">Recipient Address</div>
                    <input type="text" id="qcadRecipient" placeholder="0x... recipient public key">
                    <div class="help-text" data-i18n="qcad.recipient.help">The public key of the account receiving QCAD</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.transferAmount.label">Amount (QCAD)</div>
                    <input type="number" id="qcadTransferAmount" placeholder="Amount of QCAD to send" min="0" step="0.01">
                    <div class="help-text" data-i18n="qcad.transferAmount.help">QCAD amount to transfer</div>
                </div>

                <button class="action-button" onclick="transferQcad()" id="transferQcadBtn" disabled data-i18n="qcad.transferButton">Transfer QCAD</button>
                <div class="result-box" id="transferQcadResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="qcad.liquidate.title">Liquidate Undercollateralized Vault</div>
                <div class="lcars-subtitle" data-i18n="qcad.liquidate.subtitle">Repay debt on a vault below 120% collateral ratio to claim collateral</div>

                <div class="info-box">
                    <h4 data-i18n="qcad.liquidate.info.title">How Liquidation Works</h4>
                    <p data-i18n="qcad.liquidate.info.p1">When a vault's collateral ratio falls below 120%, anyone can liquidate it by repaying the QCAD debt. The liquidator receives the collateral plus a 13% bonus.</p>
                    <p style="margin-top: 8px;" data-i18n="qcad.liquidate.info.warning"><strong>Warning:</strong> Only liquidate vaults that are actually undercollateralized. Check the current QMHY/CAD price before attempting.</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="qcad.liquidateId.label">Vault ID to Liquidate</div>
                    <input type="number" id="liquidateVaultId" placeholder="Enter vault ID to liquidate" min="0">
                    <div class="help-text" data-i18n="qcad.liquidateId.help">The ID of an undercollateralized vault</div>
                </div>

                <button class="action-button" onclick="liquidateVault()" id="liquidateBtn" disabled data-i18n="qcad.liquidate.button">Liquidate Vault</button>
                <div class="result-box" id="liquidateResult"></div>
            </div>
        </div>

        <!-- ==================== TRUST (FIDEICOMMIS) SECTION ==================== -->
        <div id="section-trust" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="trust.title">Fideicommis Trust Accounts</div>
                <div class="lcars-subtitle" data-i18n="trust.subtitle">Quebec Civil Code-compliant trust accounts for estate planning and asset protection</div>

                <div class="info-box">
                    <h4 data-i18n="trust.what.title">What is a Fideicommis?</h4>
                    <p data-i18n="trust.what.p1">A fideicommis (Latin: "entrusted faith") is a civil law trust arrangement recognized in Quebec and other civil law jurisdictions. It allows a <strong>constituant</strong> (settlor) to set aside assets for beneficiaries with time-based conditions.</p>

                    <h4 style="margin-top: 16px;" data-i18n="trust.roles.title">Key Roles</h4>
                    <ul>
                        <li data-i18n="trust.roles.li1"><strong>Constituant:</strong> The person creating and funding the trust</li>
                        <li data-i18n="trust.roles.li2"><strong>Fiduciary:</strong> The trustee managing the trust (can be the constituant)</li>
                        <li data-i18n="trust.roles.li3"><strong>Greve:</strong> Primary beneficiary who can claim before the trigger date</li>
                        <li data-i18n="trust.roles.li4"><strong>Appele:</strong> Substitute beneficiary who receives remaining funds after the trigger</li>
                    </ul>

                    <h4 style="margin-top: 16px;" data-i18n="trust.how.title">How It Works</h4>
                    <ol style="margin: 8px 0 8px 20px; color: var(--muted);">
                        <li data-i18n="trust.how.li1">Constituant creates a trust with initial deposit</li>
                        <li data-i18n="trust.how.li2">Greve can claim funds before the trigger block (if allowed)</li>
                        <li data-i18n="trust.how.li3">At trigger block, remaining funds go to Appele</li>
                        <li data-i18n="trust.how.li4">Revocable trusts can be cancelled by constituant</li>
                    </ol>

                    <h4 style="margin-top: 16px;" data-i18n="trust.legal.title">Legal Framework</h4>
                    <p data-i18n="trust.legal.p1">This implementation follows Articles 1260-1298 of the Quebec Civil Code regarding trusts (fiducie). It provides on-chain enforcement of trust terms with post-quantum cryptographic security.</p>
                </div>

                <div class="warning-box" id="trustAccountWarning">
                    <h4 data-i18n="trust.warning.title">Account Required</h4>
                    <p data-i18n="trust.warning.p1">You need to unlock your keystore in the <strong>ACCOUNT</strong> section before creating or managing trusts.</p>
                </div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="trust.create.title">Create New Trust</div>
                <div class="lcars-subtitle" data-i18n="trust.create.subtitle">Establish a fideicommis trust account</div>

                <div class="info-box">
                    <h4 data-i18n="trust.create.info.title">Trust Parameters</h4>
                    <p data-i18n="trust.create.info.p1">Define the beneficiaries, timing, and initial funding for your trust. The minimum duration is 1 day (28,800 blocks at 3 seconds per block).</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.name.label">Trust Name</div>
                    <input type="text" id="trustName" placeholder="e.g., Family Education Fund" maxlength="64">
                    <div class="help-text" data-i18n="trust.name.help">A descriptive name for this trust (max 64 characters)</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.fiduciary.label">Fiduciary (Trustee) Address</div>
                    <input type="text" id="trustFiduciary" placeholder="0x... fiduciary public key (can be your own)">
                    <div class="help-text" data-i18n="trust.fiduciary.help">The account that will manage the trust</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.greve.label">Greve (Primary Beneficiary) Address</div>
                    <input type="text" id="trustGreve" placeholder="0x... greve public key">
                    <div class="help-text" data-i18n="trust.greve.help">Primary beneficiary who can claim before trigger</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.appele.label">Appele (Substitute Beneficiary) Address</div>
                    <input type="text" id="trustAppele" placeholder="0x... appele public key">
                    <div class="help-text" data-i18n="trust.appele.help">Receives remaining funds after trigger (must be different from greve)</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.trigger.label">Trigger Block Number</div>
                    <input type="number" id="trustTriggerBlock" placeholder="Block number when trust transfers to appele" min="0">
                    <div class="help-text" data-i18n="trust.trigger.help">At ~3 seconds/block: 28,800 blocks = 1 day, 864,000 blocks = 30 days</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.claimBefore.label">Greve Claim Deadline (Optional)</div>
                    <input type="number" id="trustClaimBefore" placeholder="Block before which greve must claim (optional)" min="0">
                    <div class="help-text" data-i18n="trust.claimBefore.help">If set, greve can only claim before this block number</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.deposit.label">Initial Deposit (QMHY)</div>
                    <input type="number" id="trustDeposit" placeholder="Initial QMHY to fund the trust" min="0" step="0.000001">
                    <div class="help-text" data-i18n="trust.deposit.help">Minimum deposit required to create trust</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.type.label">Trust Type</div>
                    <select id="trustRevocable">
                        <option value="false" data-i18n="trust.type.irrevocable">Irrevocable - Cannot be cancelled once created</option>
                        <option value="true" data-i18n="trust.type.revocable">Revocable - Constituant can cancel and reclaim funds</option>
                    </select>
                    <div class="help-text" data-i18n="trust.type.help">Irrevocable trusts provide stronger guarantees for beneficiaries</div>
                </div>

                <button class="action-button" onclick="createTrust()" id="createTrustBtn" disabled data-i18n="trust.create.button">Create Trust</button>
                <div class="result-box" id="createTrustResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="trust.manage.title">Manage Trust</div>
                <div class="lcars-subtitle" data-i18n="trust.manage.subtitle">Deposit additional funds or cancel a revocable trust</div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.trustId.label">Trust ID</div>
                    <input type="number" id="manageTrustId" placeholder="Enter trust ID" min="0">
                    <div class="help-text" data-i18n="trust.trustId.help">The ID of the trust you want to manage</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.depositAmount.label">Deposit Amount (QMHY)</div>
                    <input type="number" id="trustDepositAmount" placeholder="Amount to add to trust" min="0" step="0.000001">
                    <div class="help-text" data-i18n="trust.depositAmount.help">Additional funds to deposit (constituant only)</div>
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px;">
                    <button class="action-button" onclick="depositToTrust()" id="depositTrustBtn" disabled data-i18n="trust.depositButton">Deposit to Trust</button>
                    <button class="action-button secondary" onclick="cancelTrust()" id="cancelTrustBtn" disabled data-i18n="trust.cancelButton">Cancel Trust</button>
                </div>

                <div class="result-box" id="manageTrustResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="trust.claim.title">Claim as Beneficiary</div>
                <div class="lcars-subtitle" data-i18n="trust.claim.subtitle">Greve or Appele can claim their entitled funds</div>

                <div class="info-box">
                    <h4 data-i18n="trust.claim.rules.title">Claiming Rules</h4>
                    <ul>
                        <li data-i18n="trust.claim.rules.li1"><strong>Greve:</strong> Can claim partial amounts before the trigger block (or greve_claim_before if set)</li>
                        <li data-i18n="trust.claim.rules.li2"><strong>Appele:</strong> Claims all remaining funds after the trigger block</li>
                    </ul>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.trustId.label">Trust ID</div>
                    <input type="number" id="claimTrustId" placeholder="Enter trust ID" min="0">
                    <div class="help-text" data-i18n="trust.trustId.help">The ID of the trust to claim from</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="trust.claimAmount.label">Claim Amount (QMHY) - Greve Only</div>
                    <input type="number" id="greveClaimAmount" placeholder="Amount to claim (greve only)" min="0" step="0.000001">
                    <div class="help-text" data-i18n="trust.claimAmount.help">Greve can claim partial amounts; Appele claims everything remaining</div>
                </div>

                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px;">
                    <button class="action-button" onclick="claimAsGreve()" id="claimGreveBtn" disabled data-i18n="trust.claimGreve.button">Claim as Greve</button>
                    <button class="action-button" onclick="claimAsAppele()" id="claimAppeleBtn" disabled data-i18n="trust.claimAppele.button">Claim as Appele</button>
                </div>

                <div class="result-box" id="claimTrustResult"></div>
            </div>
        </div>

        <!-- ==================== SETTINGS SECTION ==================== -->
        <div id="section-settings" class="section">
            <div class="lcars-display">
                <div class="lcars-title" data-i18n="settings.title">Blockchain Connection</div>
                <div class="lcars-subtitle" data-i18n="settings.subtitle">Configure your connection to the QuantumHarmony blockchain network</div>

                <div class="info-box">
                    <h4 data-i18n="settings.rpc.title">RPC Endpoint</h4>
                    <p data-i18n="settings.rpc.p1">The RPC endpoint is the URL of the QuantumHarmony blockchain node that this application communicates with. By default, it connects to the official Alice validator node. You can change this if you're running your own node or connecting to a different network.</p>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="settings.rpc.label">RPC Endpoint URL</div>
                    <input type="text" id="rpcEndpointInput" value="https://quantumharmony.network/rpc">
                    <div class="help-text" data-i18n="settings.rpc.help">The HTTPS URL of the blockchain RPC proxy</div>
                </div>

                <button class="action-button" onclick="saveRPCEndpoint()" data-i18n="settings.save.button">Save Endpoint</button>
                <button class="action-button secondary" onclick="testConnection()" data-i18n="settings.test.button">Test Connection</button>

                <div class="result-box" id="rpcResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="settings.ipfs.title">IPFS Storage (Optional)</div>
                <div class="lcars-subtitle" data-i18n="settings.ipfs.subtitle">Configure Pinata for decentralized document storage</div>

                <div class="info-box">
                    <h4 data-i18n="settings.ipfs.what.title">What is IPFS?</h4>
                    <p data-i18n="settings.ipfs.what.p1">IPFS (InterPlanetary File System) is a decentralized storage network. When you upload a document to IPFS, it's distributed across multiple nodes worldwide, ensuring availability and permanence.</p>

                    <h4 style="margin-top: 16px;" data-i18n="settings.ipfs.pinata.title">Pinata</h4>
                    <p data-i18n="settings.ipfs.pinata.p1">Pinata is a reliable IPFS pinning service that ensures your files stay available. You'll need a free Pinata account to use IPFS features:</p>
                    <ol style="margin: 8px 0 8px 20px; color: var(--muted);">
                        <li data-i18n="settings.ipfs.pinata.li1">Go to <strong>pinata.cloud</strong> and create a free account</li>
                        <li data-i18n="settings.ipfs.pinata.li2">Navigate to API Keys in your dashboard</li>
                        <li data-i18n="settings.ipfs.pinata.li3">Create a new API key with pinning permissions</li>
                        <li data-i18n="settings.ipfs.pinata.li4">Copy the API Key and Secret Key here</li>
                    </ol>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="settings.ipfs.apiKey.label">Pinata API Key</div>
                    <input type="text" id="pinataApiKey" placeholder="Your API Key from Pinata dashboard">
                    <div class="help-text" data-i18n="settings.ipfs.apiKey.help">Found in your Pinata dashboard under API Keys</div>
                </div>

                <div class="data-field">
                    <div class="data-label" data-i18n="settings.ipfs.secret.label">Pinata Secret Key</div>
                    <input type="password" id="pinataSecretKey" placeholder="Your Secret Key from Pinata">
                    <div class="help-text" data-i18n="settings.ipfs.secret.help">Keep this secret - it authorizes uploads to your Pinata account</div>
                </div>

                <button class="action-button" onclick="saveIPFSSettings()" data-i18n="settings.ipfs.save.button">Save IPFS Settings</button>
                <button class="action-button secondary" onclick="testIPFSConnection()" data-i18n="settings.ipfs.test.button">Test Pinata Connection</button>

                <div class="result-box" id="ipfsResult"></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title" data-i18n="settings.about.title">About This Application</div>

                <div class="info-box">
                    <h4 data-i18n="settings.about.name">QuantumHarmony Notarial Service</h4>
                    <p data-i18n="settings.about.p1">This application provides post-quantum secure document attestation and contract signing using the QuantumHarmony blockchain.</p>

                    <h4 style="margin-top: 16px;" data-i18n="settings.about.security.title">Security Features</h4>
                    <ul>
                        <li data-i18n="settings.about.security.li1"><strong>SPHINCS+ Signatures:</strong> Post-quantum secure, resistant to quantum computer attacks</li>
                        <li data-i18n="settings.about.security.li2"><strong>SHA-256 Hashing:</strong> Industry-standard cryptographic document fingerprinting</li>
                        <li data-i18n="settings.about.security.li3"><strong>AES-256-GCM Encryption:</strong> Military-grade encryption for keystore protection</li>
                        <li data-i18n="settings.about.security.li4"><strong>Client-Side Processing:</strong> Your documents and keys never leave your browser</li>
                    </ul>

                    <h4 style="margin-top: 16px;" data-i18n="settings.about.opensource.title">Open Source</h4>
                    <p data-i18n="settings.about.opensource.p1">This application is open source. View the code and contribute at:</p>
                    <p style="font-family: monospace; color: var(--accent);" data-i18n="settings.about.opensource.url">github.com/Paraxiom/quantumharmony-notarial</p>
                </div>
            </div>
        </div>

        <!-- ==================== PROOFS SECTION ==================== -->
        <div id="section-proofs" class="section">
            <div class="lcars-display">
                <div class="lcars-title">Cryptographic Proofs & Tests</div>
                <div class="lcars-subtitle">Verify the integrity of QuantumHarmony's proof systems</div>

                <!-- Stats Grid -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px;">
                    <div style="background: var(--card); border-left: 4px solid var(--success); padding: 16px; border-radius: 0 8px 8px 0;">
                        <div style="font-size: 11px; color: var(--muted); text-transform: uppercase;">PALLET TESTS</div>
                        <div style="font-size: 28px; font-weight: bold; color: var(--success);">88</div>
                    </div>
                    <div style="background: var(--card); border-left: 4px solid var(--success); padding: 16px; border-radius: 0 8px 8px 0;">
                        <div style="font-size: 11px; color: var(--muted); text-transform: uppercase;">PASSED</div>
                        <div style="font-size: 28px; font-weight: bold; color: var(--success);">88</div>
                    </div>
                    <div style="background: var(--card); border-left: 4px solid var(--navy-light); padding: 16px; border-radius: 0 8px 8px 0;">
                        <div style="font-size: 11px; color: var(--muted); text-transform: uppercase;">PEDERSEN</div>
                        <div style="font-size: 28px; font-weight: bold; color: var(--navy-light);">22</div>
                    </div>
                    <div style="background: var(--card); border-left: 4px solid var(--accent); padding: 16px; border-radius: 0 8px 8px 0;">
                        <div style="font-size: 11px; color: var(--muted); text-transform: uppercase;">STATUS</div>
                        <div style="font-size: 28px; font-weight: bold; color: var(--accent);">VERIFIED</div>
                    </div>
                </div>

                <div class="info-box">
                    <h4>Active Proof Systems</h4>
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-top: 12px;">
                        <span>Pedersen Commitments (BLS12-381)</span>
                        <span style="color: var(--success);">ACTIVE - 22 tests</span>
                        <span>Document Attestations (Blake2)</span>
                        <span style="color: var(--success);">ACTIVE - 31 tests</span>
                        <span>Academic Vouching Chain</span>
                        <span style="color: var(--success);">ACTIVE - 35 tests</span>
                        <span>VRF Proofs (Quantum-Enhanced)</span>
                        <span style="color: var(--accent);">PARTIAL</span>
                    </div>
                </div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title">Test Console</div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <span class="lcars-subtitle">Run pallet tests to verify proof integrity</span>
                    <button class="action-button" onclick="runProofTestsNotarial()">RUN TESTS</button>
                </div>

                <div id="proofConsoleNotarial" style="
                    background: #0a0a0f;
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    padding: 16px;
                    font-family: 'Fira Code', 'JetBrains Mono', monospace;
                    font-size: 11px;
                    max-height: 280px;
                    overflow-y: auto;
                    color: var(--muted);
                    white-space: pre-wrap;
                "><span style="color: #666;">$ cargo test -p pallet-pedersen-commitment -p pallet-notarial -p pallet-academic-vouch</span>

<span style="color: var(--accent);">running 22 tests (pallet-pedersen-commitment)</span>
<span style="color: var(--success);">test test_create_commitment_point_deterministic ... ok</span>
<span style="color: var(--success);">test test_verify_commitment_correct ... ok</span>
<span style="color: var(--success);">test test_information_theoretic_hiding ... ok</span>
<span style="color: var(--success);">test test_binding_property ... ok</span>
<span style="color: var(--success);">test test_full_commit_reveal_workflow ... ok</span>
<span style="color: #666;">... +17 more tests</span>

<span style="color: var(--accent);">running 31 tests (pallet-notarial)</span>
<span style="color: var(--success);">test tests::attest_document_works ... ok</span>
<span style="color: var(--success);">test tests::witness_attestation_certification ... ok</span>
<span style="color: var(--success);">test tests::generate_certificate_works ... ok</span>
<span style="color: #666;">... +28 more tests</span>

<span style="color: var(--accent);">running 35 tests (pallet-academic-vouch)</span>
<span style="color: var(--success);">test tests::vouch_for_applicant_works ... ok</span>
<span style="color: var(--success);">test tests::vouch_triggers_vouches_complete ... ok</span>
<span style="color: #666;">... +33 more tests</span>

<span style="color: var(--success); font-weight: bold;">test result: ok. 164 passed; 0 failed; 0 ignored</span></div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title">Live Pedersen Commitment Demo</div>
                <div class="lcars-subtitle">Information-theoretic hiding with computational binding</div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-top: 16px;">
                    <div>
                        <div class="data-field">
                            <div class="data-label">Entropy (32 bytes hex)</div>
                            <input type="text" id="proofEntropyNotarial" value="2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a" style="font-family: monospace; font-size: 10px;">
                        </div>
                        <div class="data-field">
                            <div class="data-label">Blinding Factor (32 bytes hex)</div>
                            <input type="text" id="proofBlindingNotarial" value="6363636363636363636363636363636363636363636363636363636363636363" style="font-family: monospace; font-size: 10px;">
                        </div>
                        <button class="action-button" onclick="computePedersenCommitmentNotarial()">COMPUTE COMMITMENT</button>
                    </div>
                    <div class="info-box" style="margin-top: 0;">
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px;">
                            <span style="color: var(--muted);">Formula:</span>
                            <span style="font-family: monospace;">C = g^entropy √ó h^blinding</span>
                            <span style="color: var(--muted);">Curve:</span>
                            <span>BLS12-381 (G1)</span>
                            <span style="color: var(--muted);">Commitment:</span>
                            <span id="proofCommitmentResultNotarial" style="font-size: 9px; word-break: break-all; color: var(--navy-light);">---</span>
                            <span style="color: var(--muted);">Properties:</span>
                            <span style="color: var(--success);">Hiding + Binding</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="lcars-display">
                <div class="lcars-title">Document Hash Verification</div>
                <div class="lcars-subtitle">SHA-256 cryptographic fingerprint verification</div>

                <div class="data-field">
                    <div class="data-label">Document Text</div>
                    <textarea id="proofDocTextNotarial" rows="2" style="font-family: monospace; font-size: 11px;">QuantumHarmony Notarial Attestation</textarea>
                </div>

                <div style="display: flex; gap: 12px; margin-bottom: 16px;">
                    <button class="action-button" onclick="computeDocumentHashNotarial()">COMPUTE HASH</button>
                    <button class="action-button secondary" onclick="verifyDocumentHashNotarial()">VERIFY</button>
                </div>

                <div class="info-box">
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px;">
                        <span style="color: var(--muted);">SHA-256 Hash:</span>
                        <span id="proofDocHashNotarial" style="font-size: 10px; word-break: break-all; font-family: monospace;">---</span>
                        <span style="color: var(--muted);">Verification:</span>
                        <span id="proofDocVerifyNotarial" style="color: var(--muted);">Not verified</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ==================== MODALS ==================== -->

    <!-- Account Modal -->
    <div class="modal-overlay" id="accountModal">
        <div class="modal">
            <div class="modal-title">Account Status</div>
            <div id="accountModalContent">
                <p style="color: var(--muted);">No account is currently unlocked.</p>
                <p style="color: var(--muted); margin-top: 8px;">Go to the <strong>ACCOUNT</strong> section to create or unlock a keystore for signing documents and contracts.</p>
            </div>
            <button class="action-button secondary" onclick="closeModal('accountModal')">Close</button>
        </div>
    </div>

    <!-- Create Contract Modal -->
    <div class="modal-overlay" id="createContractModal">
        <div class="modal">
            <div class="modal-title">Create New Contract</div>

            <div id="wizardStep1">
                <div class="info-box">
                    <h4>Step 1: Contract Details</h4>
                    <p>Enter the basic information about your contract. Be clear and specific in your description as this will form part of the legal record.</p>
                </div>

                <div class="data-field">
                    <div class="data-label">Contract Title</div>
                    <input type="text" id="contractTitle" placeholder="e.g., Service Agreement between ABC Corp and XYZ Ltd">
                    <div class="help-text">A clear, descriptive title for the contract</div>
                </div>

                <div class="data-field">
                    <div class="data-label">Contract Type</div>
                    <select id="contractType">
                        <option value="0">Academic Program Agreement</option>
                        <option value="1">Business Partnership</option>
                        <option value="2">Service Agreement</option>
                        <option value="3">Non-Disclosure Agreement (NDA)</option>
                        <option value="4">Employment Contract</option>
                        <option value="5">License Agreement</option>
                        <option value="6">Custom Contract</option>
                    </select>
                </div>

                <div class="data-field">
                    <div class="data-label">Contract Terms & Description</div>
                    <textarea id="contractDescription" rows="5" placeholder="Describe the terms, conditions, and obligations of all parties..."></textarea>
                    <div class="help-text">This text will be permanently recorded on the blockchain</div>
                </div>

                <div class="data-field">
                    <div class="data-label">Document (Optional)</div>
                    <div class="drop-zone" id="contractDocDropZone" style="padding: 20px; text-align: center; border: 2px dashed var(--border); border-radius: 8px; cursor: pointer; margin-bottom: 8px;">
                        <input type="file" id="contractDocFile" accept=".pdf,.doc,.docx,.txt" style="display: none;">
                        <p style="color: var(--muted);">Drop PDF here or click to upload</p>
                        <p style="font-size: 11px; color: var(--muted); margin-top: 4px;">SHA-256 hash will be recorded on-chain</p>
                    </div>
                    <div id="contractDocInfo" style="display: none; padding: 8px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="contractDocFileName" style="color: var(--text); font-size: 12px;"></span>
                            <button onclick="clearContractDoc()" style="background: var(--error); border: none; color: white; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
                        </div>
                        <div style="font-size: 10px; color: var(--muted); font-family: monospace; margin-top: 4px;" id="contractDocHash"></div>
                    </div>
                </div>

                <div class="data-field" id="contractStorageField" style="display: none;">
                    <div class="data-label">Document Storage</div>
                    <select id="contractStorageOption" onchange="checkContractIPFSConfig()">
                        <option value="local">Local Only - Document stays on your device</option>
                        <option value="ipfs">IPFS Public - Signers can fetch the document via signing link</option>
                        <option value="ipfs-encrypted">IPFS Encrypted - Only signers with the link can read it</option>
                    </select>
                    <div class="help-text">IPFS storage lets signers view the document inline from the signing link</div>
                    <div class="info-box" id="contractIpfsHint" style="display: none; margin-top: 8px;">
                        <p>IPFS requires Pinata API keys. Configure them in <strong>SETTINGS</strong>.</p>
                    </div>
                </div>

                <button class="action-button" onclick="wizardStep2()">Next: Add Parties</button>
            </div>

            <div id="wizardStep2" style="display: none;">
                <div class="info-box">
                    <h4>Step 2: Contract Parties</h4>
                    <p>Add all parties who will be signing this contract. Each party needs a name and their public key (from their keystore). You need at least 2 parties.</p>
                </div>

                <div class="data-field">
                    <div class="data-label">Current Parties</div>
                    <div id="partiesList" style="color: var(--muted);">No parties added yet</div>
                </div>

                <hr>

                <div class="data-field">
                    <div class="data-label">Party Name</div>
                    <input type="text" id="partyName" placeholder="e.g., John Smith, ABC Corporation">
                </div>

                <div class="data-field">
                    <div class="data-label">Party Public Key</div>
                    <input type="text" id="partyAddress" placeholder="0x... (the party's public key from their keystore)">
                    <div class="help-text">Each party can find their public key in the ACCOUNT section</div>
                </div>

                <button class="action-button secondary" onclick="addParty()">Add This Party</button>

                <hr>

                <button class="action-button" onclick="wizardStep3()">Next: Review Contract</button>
                <button class="action-button secondary" onclick="wizardBack1()">Back</button>
            </div>

            <div id="wizardStep3" style="display: none;">
                <div class="info-box">
                    <h4>Step 3: Review & Submit</h4>
                    <p>Review your contract details before submitting to the blockchain. Once submitted, the contract cannot be modified.</p>
                </div>

                <div id="contractSummary"></div>

                <button class="action-button" onclick="createContract()">Submit Contract to Blockchain</button>
                <button class="action-button secondary" onclick="wizardBack2()">Back</button>
            </div>

            <hr>
            <button class="action-button secondary" onclick="closeModal('createContractModal')">Cancel</button>
        </div>
    </div>

    <!-- Sign Contract Modal -->
    <div class="modal-overlay" id="signContractModal">
        <div class="modal">
            <div class="modal-title">Sign Contract</div>

            <div class="info-box">
                <h4>How Contract Signing Works</h4>
                <p>When you sign a contract, your SPHINCS+ signature is permanently recorded on the blockchain. This cryptographically proves your agreement to the contract terms.</p>
                <p style="margin-top: 8px;">Enter the Contract ID provided by the contract creator. You must be listed as a party to sign.</p>
            </div>

            <div class="data-field">
                <div class="data-label">Contract ID</div>
                <input type="text" id="signContractId" placeholder="Enter the contract ID (e.g., m1abc2def)">
                <div class="help-text">The contract creator will provide this ID</div>
            </div>

            <button class="action-button" onclick="signContract()">Sign Contract with My Key</button>
            <button class="action-button secondary" onclick="closeModal('signContractModal')">Cancel</button>

            <div class="result-box" id="signResult"></div>
        </div>
    </div>

    <!-- View Contract Modal -->
    <div class="modal-overlay" id="viewContractModal">
        <div class="modal">
            <div class="modal-title">View Contract Details</div>

            <div class="info-box">
                <p>Enter a Contract ID to view its details, parties, and signature status.</p>
            </div>

            <div class="data-field">
                <div class="data-label">Contract ID</div>
                <input type="text" id="viewContractId" placeholder="Enter contract ID">
            </div>

            <button class="action-button" onclick="viewContract()">Look Up Contract</button>

            <div id="contractDetails" style="display: none; margin-top: 20px;">
                <hr>
                <div class="data-field">
                    <div class="data-label">Title</div>
                    <div class="data-value" id="viewTitle">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Status</div>
                    <div class="data-value" id="viewStatus">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Parties</div>
                    <div class="data-value" id="viewParties">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Signatures</div>
                    <div class="data-value" id="viewSignatures">--</div>
                </div>
            </div>

            <hr>
            <button class="action-button secondary" onclick="closeModal('viewContractModal')">Close</button>
        </div>
    </div>

    <!-- Signing Flow Modal (6-Phase Notarial Experience for Party B) -->
    <div class="modal-overlay" id="signingFlowModal">
        <div class="modal" style="max-width: 640px;">
            <div class="modal-title" id="signingFlowTitle">Contract Signing</div>

            <!-- Phase: Loading (chain fetch) -->
            <div id="signingPhaseLoading">
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 24px; color: var(--accent); margin-bottom: 12px;">Loading Contract...</div>
                    <p style="color: var(--muted);">Fetching contract data from the QuantumHarmony blockchain</p>
                </div>
            </div>

            <!-- Phase 1: KYC Registration -->
            <div id="signingPhaseKYC" style="display: none;">
                <div class="info-box" style="border-left: 4px solid var(--accent);">
                    <h4 style="color: var(--accent);">Identity Registration</h4>
                    <p style="color: var(--muted);">Please provide your identity details. Your credentials will be emailed to you after signing.</p>
                </div>

                <div class="data-field">
                    <div class="data-label">Full Legal Name *</div>
                    <input type="text" id="kycFullName" placeholder="e.g. Jean-Pierre Tremblay" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;">
                </div>
                <div class="data-field">
                    <div class="data-label">Email Address *</div>
                    <input type="email" id="kycEmail" placeholder="your@email.com" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;">
                    <div style="color: var(--muted); font-size: 11px; margin-top: 4px;">Your blockchain credentials will be sent to this email</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Phone (Optional)</div>
                    <input type="tel" id="kycPhone" placeholder="+1 (514) 555-0123" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;">
                </div>
                <div class="data-field">
                    <div class="data-label">Mailing Address *</div>
                    <input type="text" id="kycAddress" placeholder="123 Rue Saint-Jacques, Montreal, QC H2Y 1L6" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;">
                </div>
                <div class="data-field">
                    <div class="data-label">Date of Birth *</div>
                    <input type="date" id="kycDateOfBirth" style="width: 100%; padding: 10px 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px;">
                </div>

                <div class="result-box" id="kycResult"></div>

                <button class="action-button" onclick="submitKYC()" style="background: var(--accent); font-size: 16px; padding: 14px 28px; width: 100%; margin-top: 12px;">
                    Continue to Document Review
                </button>
            </div>

            <!-- Phase 2: Document Review -->
            <div id="signingPhaseReview" style="display: none;">
                <div class="info-box" style="border-left: 4px solid var(--accent);">
                    <h4 style="color: var(--accent);">Review This Agreement</h4>
                    <p style="color: var(--muted);">Review the contract details below. Take your time ‚Äî you can close this page and return later.</p>
                </div>

                <div class="data-field">
                    <div class="data-label">Contract Title</div>
                    <div class="data-value" id="signingContractTitle" style="font-size: 16px; font-weight: 600;">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Contract Type</div>
                    <div class="data-value" id="signingContractType">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Status</div>
                    <div class="data-value" id="signingContractStatus">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Document Hash</div>
                    <div class="data-value" id="signingDocHash" style="font-size: 10px; font-family: monospace; word-break: break-all;">--</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Parties</div>
                    <div id="signingPartiesList">--</div>
                </div>

                <!-- IPFS Document Viewer -->
                <div id="signingIPFSDocSection" style="display: none;">
                    <div id="signingDocLoading" style="display: none; text-align: center; padding: 24px;">
                        <div class="spinner" style="display: inline-block;"></div>
                        <div style="color: var(--muted); margin-top: 8px;">Fetching document from IPFS...</div>
                    </div>
                    <div id="signingDocError" style="display: none;">
                        <div class="result-box error" id="signingDocErrorMsg">Failed to fetch document.</div>
                    </div>
                    <div id="signingHashBadge" style="display: none; padding: 12px; border-radius: 8px; margin-bottom: 12px; font-weight: 600;"></div>
                    <div id="signingDocViewer" style="display: none;">
                        <div class="data-field">
                            <div class="data-label" id="signingDocLabel">Document</div>
                        </div>
                        <div id="signingDocContent" style="border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: #fff; min-height: 200px;"></div>
                        <div style="margin-top: 6px; font-size: 10px; color: var(--muted); font-family: monospace;" id="signingDocCidInfo"></div>
                    </div>
                </div>

                <div class="data-field">
                    <div class="data-label">Verify Document (Optional)</div>
                    <div class="drop-zone" id="signingVerifyDropZone" style="padding: 16px; text-align: center; border: 2px dashed var(--border); border-radius: 8px; cursor: pointer;">
                        <input type="file" id="signingVerifyFile" style="display: none;">
                        <p style="color: var(--muted); font-size: 12px;">Drop your copy of the document here to verify it matches</p>
                    </div>
                    <div id="signingVerifyResult" style="display: none; margin-top: 8px; padding: 8px; border-radius: 6px; font-size: 12px;"></div>
                </div>

                <button class="action-button secondary" onclick="downloadContractSummary()" style="width: 100%; margin-top: 8px; font-size: 13px; padding: 10px 16px;">
                    Download Contract Summary (.txt)
                </button>

                <div class="info-box" style="border-left: 4px solid var(--navy-light); margin-top: 12px;">
                    <p style="color: var(--muted); font-size: 12px;">Take your time. You can close this page and return later using the same signing link.</p>
                </div>

                <button class="action-button" onclick="showSignaturePhase()" style="background: var(--success); font-size: 16px; padding: 16px 32px; width: 100%; margin-top: 12px;">
                    I Have Reviewed the Document ‚Äî Ready to Sign
                </button>
            </div>

            <!-- Phase 3: Signature Drawing -->
            <div id="signingPhaseSignature" style="display: none;">
                <div class="info-box" style="border-left: 4px solid var(--accent);">
                    <h4 style="color: var(--accent);">Draw Your Signature</h4>
                    <p style="color: var(--muted);">Use your mouse or finger to draw your signature below.</p>
                </div>

                <div class="data-field" style="margin-top: 16px;">
                    <div class="data-label" style="font-size: 14px; font-weight: 600; color: var(--accent);">Your Signature</div>
                    <div style="position: relative; border: 2px solid var(--border); border-radius: 8px; background: #0a0e1a; overflow: hidden;">
                        <canvas id="signaturePadCanvas" width="576" height="160" style="display: block; width: 100%; cursor: crosshair; touch-action: none;"></canvas>
                        <div id="signaturePadPlaceholder" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); font-size: 14px; pointer-events: none; opacity: 0.5;">Sign here</div>
                        <button onclick="clearSignaturePad()" style="position: absolute; top: 6px; right: 6px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); color: var(--muted); padding: 2px 10px; border-radius: 4px; font-size: 11px; cursor: pointer;">Clear</button>
                    </div>
                </div>

                <button class="action-button" id="signingSignBtn" onclick="signingOneClickSign()" style="background: var(--success); font-size: 16px; padding: 16px 32px; width: 100%; margin-top: 12px; opacity: 0.4; pointer-events: none;" disabled>
                    Draw your signature above to sign
                </button>
                <div class="result-box" id="signingSignResult"></div>
            </div>

            <!-- Phase 5: Key Display + Forced Destruction -->
            <div id="signingPhaseKeys" style="display: none;">
                <div style="text-align: center; padding: 20px; background: var(--bg); border: 2px solid var(--success); border-radius: 12px; margin: 16px 0;">
                    <div style="font-size: 48px; color: var(--success); margin-bottom: 8px;">&#10003;</div>
                    <div style="font-size: 20px; font-weight: bold; color: var(--success); margin-bottom: 8px;">Agreement Signed</div>
                    <div style="text-align: center; margin-bottom: 16px;">
                        <img id="signingSuccessSigImg" style="max-width: 280px; border: 1px solid var(--border); border-radius: 8px; background: #0a0e1a; display: none;">
                    </div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 12px;">
                        <span style="color: var(--muted);">Contract ID:</span>
                        <span id="signingSuccessId" style="color: var(--text); font-family: monospace;">--</span>
                        <span style="color: var(--muted);">Signer:</span>
                        <span id="signingSuccessAddress" style="color: var(--text); font-family: monospace; word-break: break-all; font-size: 10px;">--</span>
                        <span style="color: var(--muted);">Transaction:</span>
                        <span id="signingSuccessTx" style="color: var(--text); font-family: monospace; font-size: 10px;">--</span>
                        <span style="color: var(--muted);">Timestamp:</span>
                        <span id="signingSuccessTime" style="color: var(--text);">--</span>
                    </div>
                </div>

                <!-- Credential display with destruction -->
                <div id="signingKeysCredentials" style="margin-top: 12px; padding: 16px; background: rgba(218, 54, 51, 0.08); border: 2px solid var(--error); border-radius: 8px;">
                    <div style="font-weight: 700; color: var(--error); margin-bottom: 8px; font-size: 15px;">CRITICAL: Save These Keys Before Leaving</div>
                    <p style="color: var(--muted); font-size: 11px; margin-bottom: 12px;">A post-quantum SPHINCS+ account was created for you. These keys prove your identity on-chain. Save them now ‚Äî they will be destroyed from this browser.</p>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 6px; font-size: 12px; background: var(--bg); padding: 12px; border-radius: 6px;">
                        <span style="color: var(--muted);">Account:</span>
                        <span id="signingKeysAddress" style="color: var(--text); font-family: monospace; word-break: break-all;">--</span>
                        <span style="color: var(--muted);">Public Key:</span>
                        <span id="signingKeysPublicKey" style="color: var(--text); font-family: monospace; word-break: break-all; font-size: 10px;">--</span>
                        <span style="color: var(--muted);">Password:</span>
                        <span id="signingKeysPassword" style="color: var(--text); font-family: monospace;">--</span>
                    </div>
                    <div id="signingKeysEmailInfo" style="margin-top: 8px; padding: 8px; background: rgba(35, 134, 54, 0.1); border-radius: 6px; font-size: 11px; color: var(--success); display: none;">
                        Your credentials have also been emailed to <span id="signingKeysEmailAddr"></span>.
                    </div>
                    <div style="margin-top: 12px; display: flex; gap: 8px;">
                        <button class="action-button secondary" onclick="downloadCredentials()" style="font-size: 12px; padding: 8px 16px; flex: 1;">Download Credentials</button>
                        <button class="action-button secondary" onclick="copyCredentials()" style="font-size: 12px; padding: 8px 16px; flex: 1;">Copy to Clipboard</button>
                    </div>
                </div>

                <button class="action-button" id="signingDestroyKeysBtn" onclick="destroyKeys()" style="background: var(--error); font-size: 16px; padding: 16px 32px; width: 100%; margin-top: 16px;">
                    I Have Saved My Keys ‚Äî Destroy From Browser
                </button>
            </div>

            <!-- Phase 6: Complete -->
            <div id="signingPhaseComplete" style="display: none;">
                <div style="text-align: center; padding: 40px; background: var(--bg); border: 2px solid var(--success); border-radius: 12px; margin: 16px 0;">
                    <div style="font-size: 48px; color: var(--success); margin-bottom: 8px;">&#10003;</div>
                    <div style="font-size: 22px; font-weight: bold; color: var(--success); margin-bottom: 16px;">Signing Complete</div>
                    <p style="color: var(--muted); font-size: 13px; line-height: 1.6;">
                        Your signature is permanently recorded on the QuantumHarmony blockchain.<br>
                        Your credentials have been emailed to you.<br>
                        Keys have been destroyed from this browser.
                    </p>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px; text-align: left; font-size: 12px; margin-top: 16px;">
                        <span style="color: var(--muted);">Contract ID:</span>
                        <span id="signingCompleteId" style="color: var(--text); font-family: monospace;">--</span>
                        <span style="color: var(--muted);">Signed at:</span>
                        <span id="signingCompleteTime" style="color: var(--text);">--</span>
                        <span style="color: var(--muted);">Transaction:</span>
                        <span id="signingCompleteTx" style="color: var(--text); font-family: monospace; font-size: 10px;">--</span>
                    </div>
                </div>
            </div>

            <hr>
            <button class="action-button secondary" id="signingFlowCloseBtn" onclick="closeModal('signingFlowModal')">Close</button>
        </div>
    </div>

    <!-- Signing Link Modal (shown after contract creation) -->
    <div class="modal-overlay" id="signingLinkModal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-title">Contract Created On-Chain</div>

            <div style="text-align: center; padding: 16px; background: var(--bg); border: 2px solid var(--success); border-radius: 12px; margin: 16px 0;">
                <div style="font-size: 36px; color: var(--success); margin-bottom: 8px;">&#10003;</div>
                <div style="font-size: 16px; font-weight: bold; color: var(--success);">Contract Submitted Successfully</div>
            </div>

            <div class="data-field">
                <div class="data-label">On-Chain Contract ID</div>
                <div class="data-value" id="signingLinkContractId" style="font-size: 20px; font-weight: bold; color: var(--accent);">--</div>
            </div>

            <div class="data-field">
                <div class="data-label">Signing Link</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="text" id="signingLinkUrl" readonly style="font-size: 11px; font-family: monospace; flex: 1;">
                    <button class="action-button" onclick="copySigningLink()" style="white-space: nowrap;">Copy Link</button>
                </div>
                <div class="help-text">Share this link with the other parties so they can sign the contract</div>
            </div>

            <div class="info-box">
                <h4>Next Steps</h4>
                <ol style="margin-left: 16px; color: var(--muted);">
                    <li>Copy the signing link above</li>
                    <li>Send it to each party who needs to sign</li>
                    <li>They can open the link to review and sign the contract</li>
                    <li>Once all parties sign, the contract status changes to Active</li>
                </ol>
            </div>

            <hr>
            <button class="action-button secondary" onclick="closeModal('signingLinkModal')">Close</button>
        </div>
    </div>

    <script>
        // ==================== State ====================
        let currentKeystore = null;
        let unlockedKey = null;
        let selectedFile = null;
        let selectedFileHash = null;
        let contractParties = [];

        // Transport detection: QSSH tunnel (localhost:9944) ‚Üí PQ-SECURED, else nginx PQ TLS ‚Üí PQ-TLS
        let transportMode = 'DETECTING';
        let faucetBase = 'https://quantumharmony.network/faucet';

        async function detectTransport() {
            // Only probe localhost when page is served from localhost (QSSH tunnel scenario)
            // Remote origins can't access loopback ‚Äî skip to avoid CORS errors
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                try {
                    const r = await fetch('http://localhost:9944', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'system_chain', params: [] }),
                        signal: AbortSignal.timeout(1000),
                    });
                    const data = await r.json();
                    if (data.result) return { mode: 'PQ-SECURED', rpc: 'http://localhost:9944', faucet: 'http://localhost:8085' };
                } catch {}
            }
            return { mode: 'PQ-TLS', rpc: 'https://quantumharmony.network/rpc', faucet: 'https://quantumharmony.network/faucet' };
        }

        function updateTransportBadge(mode) {
            const badge = document.getElementById('transportBadge');
            if (!badge) return;
            badge.textContent = mode;
            if (mode === 'PQ-SECURED') {
                badge.style.background = '#22c55e';
                badge.style.color = '#000';
            } else if (mode === 'PQ-TLS') {
                badge.style.background = '#3b82f6';
                badge.style.color = '#fff';
            } else {
                badge.style.background = '#ef4444';
                badge.style.color = '#fff';
            }
        }

        // Initialize endpoint from transport detection
        let rpcEndpoint = 'https://quantumharmony.network/rpc'; // default until detection completes
        (async () => {
            const transport = await detectTransport();
            transportMode = transport.mode;
            rpcEndpoint = transport.rpc;
            faucetBase = transport.faucet;
            updateTransportBadge(transportMode);
            // Update display and reconnect
            const epDisplay = document.getElementById('rpcEndpoint');
            if (epDisplay) epDisplay.textContent = rpcEndpoint;
        })();

        const NOTARIAL_PALLET_INDEX = 21;
        const RICARDIAN_PALLET_INDEX = 24;
        const FIDEICOMMIS_PALLET_INDEX = 22;
        const STABLECOIN_PALLET_INDEX = 23;

        // Validator faucet key - must be set via environment or server-side configuration
        const VALIDATOR_FAUCET_KEY = process.env?.FAUCET_SECRET_KEY || prompt('Enter validator faucet key:') || '';

        // Convert 64-byte SPHINCS+ public key hex to 32-byte AccountId32 via Keccak-256
        function pubKeyToAccountId(pubKeyHex) {
            const bytes = new Uint8Array(hexToBytes(pubKeyHex));
            const hash = keccak_256(bytes);
            // js-sha3 should return hex string, but guard against array return
            if (typeof hash === 'string') {
                return hash.replace(/^0x/, '');
            }
            return Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Convert byte array to hex string
        function bytesToHex(bytes) {
            return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Compute the validator faucet AccountId32 from its SPHINCS+ secret key
        let _validatorAccountId = null;
        function getValidatorAccountId() {
            if (_validatorAccountId) return _validatorAccountId;
            // SPHINCS+ SK layout: [secret_seed(32) | sk_prf(32) | pk_seed(32) | pk_root(32)]
            // Public key = last 64 bytes (pk_seed + pk_root) = last 128 hex chars
            const skHex = VALIDATOR_FAUCET_KEY.replace('0x', '');
            const pkHex = skHex.slice(128); // last 64 bytes
            _validatorAccountId = pubKeyToAccountId('0x' + pkHex);
            return _validatorAccountId;
        }

        // Query the next valid nonce for an account via gateway RPC
        async function queryNonce(accountIdHex) {
            const id = accountIdHex.replace('0x', '');
            return await rpcCall('gateway_nonce', ['0x' + id]);
        }

        // Fund an account directly via validator Balances.transfer (replaces broken faucet container)
        async function fundAccountDirect(pubKeyHex, amountQMHY = 100) {
            const accountId = pubKeyToAccountId(pubKeyHex);
            const amountUnits = BigInt(amountQMHY) * 1000000000000n; // 1 QMHY = 10^12 units
            const compactAmtArr = encodeCompactU128(amountUnits); // returns byte array
            const compactAmtHex = bytesToHex(compactAmtArr);

            // Balances.transfer_allow_death: pallet 5, call 0
            // MultiAddress::Id = 0x00 + 32-byte AccountId32
            const callData = '0x0500' + '00' + accountId + compactAmtHex;

            // Query the on-chain nonce, then probe past any pending pool txs
            const validatorAccountId = getValidatorAccountId();
            let nonce = await queryNonce(validatorAccountId);

            // Count pending extrinsics to estimate pool depth
            try {
                const pending = await rpcCall('author_pendingExtrinsics', []);
                if (Array.isArray(pending) && pending.length > 0) {
                    // Each pending tx from our validator bumps the effective nonce
                    const validatorPrefix = validatorAccountId.toLowerCase();
                    const ours = pending.filter(ext => ext.toLowerCase().includes(validatorPrefix));
                    if (ours.length > 0) {
                        nonce += ours.length;
                        console.log('fundAccountDirect: skipping', ours.length, 'pending pool txs, starting at nonce', nonce);
                    }
                }
            } catch (e) {
                console.warn('fundAccountDirect: could not check pending pool:', e.message);
            }

            console.log('fundAccountDirect: sending', amountQMHY, 'QMHY, nonce:', nonce);
            console.log('  AccountId32:', accountId);
            console.log('  callData:', callData);

            // Retry up to 10 times on nonce collision (pool may have queued txs)
            for (let attempt = 0; attempt < 10; attempt++) {
                try {
                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        callData: callData,
                        signerKey: VALIDATOR_FAUCET_KEY,
                        nonce: nonce + attempt
                    }]);
                    console.log('fundAccountDirect result (nonce', nonce + attempt + '):', JSON.stringify(result));
                    return result;
                } catch (e) {
                    const msg = e.message || '';
                    if ((msg.includes('Too low priority') || msg.includes('Already imported')) && attempt < 9) {
                        console.warn('fundAccountDirect: nonce', nonce + attempt, 'taken, trying', nonce + attempt + 1);
                        continue;
                    }
                    throw e;
                }
            }
        }

        // ==================== Toast Notifications ====================
        function showToast(type, title, message = '', duration = 5000) {
            const container = document.getElementById('toastContainer');
            const icons = { success: '‚úì', error: '‚úï', warning: '‚ö†', info: '‚Ñπ' };

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || '‚Ñπ'}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    ${message ? `<div class="toast-message">${message}</div>` : ''}
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
            `;

            container.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => toast.remove(), 300);
            }, duration);

            return toast;
        }

        // ==================== Loading States ====================
        function setButtonLoading(btn, loading) {
            if (loading) {
                btn.classList.add('btn-loading');
                btn.disabled = true;
                btn.dataset.originalText = btn.textContent;
            } else {
                btn.classList.remove('btn-loading');
                btn.disabled = false;
                if (btn.dataset.originalText) {
                    btn.textContent = btn.dataset.originalText;
                }
            }
        }

        async function withLoading(btn, asyncFn) {
            const button = typeof btn === 'string' ? document.querySelector(btn) : btn;
            if (button) setButtonLoading(button, true);
            try {
                return await asyncFn();
            } finally {
                if (button) setButtonLoading(button, false);
            }
        }

        // ==================== Offline Detection ====================
        let isOnline = navigator.onLine;

        function updateOnlineStatus() {
            const banner = document.getElementById('offlineBanner');
            if (navigator.onLine) {
                banner.classList.remove('visible');
                if (!isOnline) {
                    showToast('success', 'Connection Restored');
                    testConnection(); // Reconnect
                }
                isOnline = true;
            } else {
                banner.classList.add('visible');
                if (isOnline) {
                    showToast('error', 'Connection Lost', 'Check your network');
                }
                isOnline = false;
            }
        }

        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // ==================== Form Validation ====================
        function validateInput(input, validator, errorMsg) {
            const isValid = validator(input.value);
            input.classList.toggle('invalid', !isValid);
            input.classList.toggle('valid', isValid && input.value.length > 0);
            return isValid;
        }

        function validateSS58(address) {
            return /^5[a-zA-Z0-9]{47}$/.test(address);
        }

        function validateNotEmpty(value) {
            return value && value.trim().length > 0;
        }

        function validateAmount(value) {
            return !isNaN(parseFloat(value)) && parseFloat(value) > 0;
        }

        // ==================== Init ====================
        document.addEventListener('DOMContentLoaded', () => {
            updateTime();
            setInterval(updateTime, 1000);
            loadKeystores();
            loadAttestationHistory();
            loadContracts();
            loadSettings();
            testConnection();
            setupDropZones();
            setupContractDocDropZone();
            updateWarnings();
            // Initialize EmailJS (configure your public key at emailjs.com)
            if (typeof emailjs !== 'undefined') {
                emailjs.init({ publicKey: 'YOUR_EMAILJS_PUBLIC_KEY' });
            }
            // Check for #sign/<id> URL routing
            checkSigningRoute();
        });

        function updateTime() {
            const now = new Date();
            document.getElementById('currentTime').textContent = now.toUTCString().split(' ')[4];
        }

        function updateWarnings() {
            const attestWarning = document.getElementById('attestAccountWarning');
            const contractWarning = document.getElementById('contractAccountWarning');
            const qcadWarning = document.getElementById('qcadAccountWarning');
            const trustWarning = document.getElementById('trustAccountWarning');

            // QCAD buttons
            const qcadButtons = [
                'openVaultBtn', 'depositCollateralBtn', 'withdrawCollateralBtn',
                'mintMoreBtn', 'repayBtn', 'closeVaultBtn', 'transferQcadBtn', 'liquidateBtn'
            ];

            // Trust buttons
            const trustButtons = [
                'createTrustBtn', 'depositTrustBtn', 'cancelTrustBtn',
                'claimGreveBtn', 'claimAppeleBtn'
            ];

            if (unlockedKey) {
                attestWarning.style.display = 'none';
                contractWarning.style.display = 'none';
                if (qcadWarning) qcadWarning.style.display = 'none';
                if (trustWarning) trustWarning.style.display = 'none';

                // Enable QCAD buttons
                qcadButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = false;
                });

                // Enable Trust buttons
                trustButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = false;
                });
            } else {
                attestWarning.style.display = 'block';
                contractWarning.style.display = 'block';
                if (qcadWarning) qcadWarning.style.display = 'block';
                if (trustWarning) trustWarning.style.display = 'block';

                // Disable QCAD buttons
                qcadButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = true;
                });

                // Disable Trust buttons
                trustButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = true;
                });
            }
        }

        // ==================== Navigation ====================
        function showSection(name, el) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.getElementById('section-' + name).classList.add('active');
            document.querySelectorAll('.lcars-panel[data-section]').forEach(p => p.classList.remove('active'));
            if (el) el.classList.add('active');
        }

        // ==================== Modals ====================
        function showAccountModal() {
            document.getElementById('accountModal').classList.add('active');
            updateAccountModalContent();
        }

        function showCreateContractModal() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore in ACCOUNT section');
                return;
            }
            document.getElementById('createContractModal').classList.add('active');
            document.getElementById('wizardStep1').style.display = 'block';
            document.getElementById('wizardStep2').style.display = 'none';
            document.getElementById('wizardStep3').style.display = 'none';
            contractParties = [];
            updatePartiesList();
        }

        function showSignContractModal() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore in ACCOUNT section');
                return;
            }
            document.getElementById('signContractModal').classList.add('active');
            document.getElementById('signResult').style.display = 'none';
        }

        function showViewContractModal() {
            document.getElementById('viewContractModal').classList.add('active');
            document.getElementById('contractDetails').style.display = 'none';
        }

        function closeModal(id) {
            // Guard: prevent closing if keys are displayed but not destroyed
            if (id === 'signingFlowModal' && signingKeysDisplayedNotDestroyed) {
                showToast('warning', 'Keys Not Destroyed', 'You must save and destroy your keys before closing.');
                return;
            }
            document.getElementById(id).classList.remove('active');
        }

        // ==================== File Handling ====================
        function setupDropZones() {
            setupDropZone('attestDropZone', 'attestFile', handleAttestFile);
            setupDropZone('verifyDropZone', 'verifyFile', handleVerifyFile);
        }

        function setupDropZone(zoneId, inputId, handler) {
            const zone = document.getElementById(zoneId);
            const input = document.getElementById(inputId);

            zone.addEventListener('click', () => input.click());
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });
            zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');
                if (e.dataTransfer.files.length) handler(e.dataTransfer.files[0]);
            });
            input.addEventListener('change', (e) => {
                if (e.target.files.length) handler(e.target.files[0]);
            });
        }

        async function handleAttestFile(file) {
            selectedFile = file;
            selectedFileHash = await hashFile(file);
            document.getElementById('attestFileName').textContent = `${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('attestFileHash').textContent = selectedFileHash;
            document.getElementById('attestFileInfo').style.display = 'block';
            document.getElementById('attestBtn').disabled = !unlockedKey;
        }

        async function handleVerifyFile(file) {
            const hash = await hashFile(file);
            document.getElementById('verifyHash').value = hash;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        async function hashFile(file) {
            const buffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // ==================== Keystore ====================
        function loadKeystores() {
            const keystores = QHKeystore.loadKeystores();
            const select = document.getElementById('keystoreSelect');
            select.innerHTML = '<option value="">-- Select a keystore to unlock --</option>';
            keystores.forEach((ks, index) => {
                const opt = document.createElement('option');
                opt.value = ks.id;
                // Name and date are stored in meta object
                const name = ks.meta?.name || ks.name || `Keystore ${index + 1}`;
                const created = ks.meta?.created || ks.createdAt;
                const dateStr = created ? new Date(created).toLocaleDateString() : 'unknown date';
                opt.textContent = name + ' (created ' + dateStr + ')';
                select.appendChild(opt);
            });
        }

        function clearAllKeystores() {
            // Skip confirm() as it's blocked by wallet extensions
            localStorage.removeItem('qh_keystores');
            localStorage.removeItem('qh_active_keystore');
            if (unlockedKey) {
                lockKeystore();
            }
            currentKeystore = null;
            loadKeystores();
            document.getElementById('keystoreUnlockSection').style.display = 'none';
            document.getElementById('keystoreInfo').style.display = 'none';
            showResult('accountResult', 'success', 'All keystores cleared. Create a new keystore to continue.');
        }

        function deleteSelectedKeystore() {
            const select = document.getElementById('keystoreSelect');
            const id = select.value;
            if (!id) {
                showResult('accountResult', 'error', 'Please select a keystore to delete');
                return;
            }

            const keystore = QHKeystore.loadKeystores().find(k => k.id === id);
            if (!keystore) return;

            const keystoreName = keystore.meta?.name || keystore.name || 'this keystore';

            // Lock if this is the currently unlocked keystore
            if (unlockedKey && currentKeystore && currentKeystore.id === id) {
                lockKeystore();
            }

            QHKeystore.deleteKeystore(id);
            loadKeystores();
            document.getElementById('keystoreUnlockSection').style.display = 'none';
            document.getElementById('keystoreInfo').style.display = 'none';
            showResult('accountResult', 'success', `Keystore "${keystoreName}" deleted successfully`);
        }

        // Alice validator secret key - must be provided at runtime, never hardcoded
        const ALICE_SECRET_KEY = prompt('Enter Alice secret key:') || '';

        async function importAliceKey() {
            const password = document.getElementById('aliceKeyPassword').value;

            if (!password || password.length < 8) {
                showResult('accountResult', 'error', 'Please enter a password of at least 8 characters');
                return;
            }

            try {
                // Check if Alice key already exists
                const existing = QHKeystore.loadKeystores().find(k => k.name === 'Alice Validator');
                if (existing) {
                    showResult('accountResult', 'error', 'Alice Validator keystore already exists. Select it from the dropdown above.');
                    return;
                }

                showResult('accountResult', 'success', 'Importing Alice test account...');

                // Parse the hex secret key
                const cleanHex = ALICE_SECRET_KEY.slice(2);
                const secretKey = new Uint8Array(128);
                for (let i = 0; i < 128; i++) {
                    secretKey[i] = parseInt(cleanHex.substr(i * 2, 2), 16);
                }

                const publicKey = secretKey.slice(64, 128);
                const keypair = { secretKey, publicKey };

                const keystore = await QHKeystore.createKeystore(keypair, password, 'Alice Validator');
                QHKeystore.saveKeystore(keystore);

                document.getElementById('aliceKeyPassword').value = '';
                loadKeystores();

                // Auto-select the new keystore
                document.getElementById('keystoreSelect').value = keystore.id;
                selectKeystore();

                showResult('accountResult', 'success', 'Alice Validator imported! Enter your password above to unlock.');
            } catch (e) {
                showResult('accountResult', 'error', 'Failed to import: ' + e.message);
            }
        }

        function selectKeystore() {
            const id = document.getElementById('keystoreSelect').value;
            if (id) {
                currentKeystore = QHKeystore.loadKeystores().find(k => k.id === id);
                document.getElementById('keystoreUnlockSection').style.display = 'block';
                document.getElementById('keystoreInfo').style.display = 'none';
            } else {
                currentKeystore = null;
                document.getElementById('keystoreUnlockSection').style.display = 'none';
                document.getElementById('keystoreInfo').style.display = 'none';
            }
        }

        async function unlockKeystore() {
            if (!currentKeystore) {
                showResult('accountResult', 'error', 'Please select a keystore first from the dropdown above');
                return;
            }
            const password = document.getElementById('keystorePassword').value;
            if (!password) {
                showResult('accountResult', 'error', 'Please enter your password');
                return;
            }

            try {
                console.log('Attempting to unlock keystore:', currentKeystore.id);
                console.log('Keystore crypto format:', currentKeystore.crypto?.cipher);

                unlockedKey = await QHKeystore.unlockKeystore(currentKeystore, password);
                console.log('Unlock successful, public key length:', unlockedKey.publicKey?.length);

                // Display public key as hex string
                const pkHex = unlockedKey.publicKey instanceof Uint8Array
                    ? '0x' + Array.from(unlockedKey.publicKey).map(b => b.toString(16).padStart(2, '0')).join('')
                    : unlockedKey.publicKey;
                document.getElementById('publicKeyDisplay').textContent = pkHex.slice(0, 20) + '...' + pkHex.slice(-16);

                document.getElementById('keystoreUnlockSection').style.display = 'none';
                document.getElementById('keystoreInfo').style.display = 'block';
                document.getElementById('keystorePassword').value = '';

                // Update faucet/transfer section with proper SS58 address
                let displayAddress = currentKeystore.address;
                if (!displayAddress || typeof displayAddress !== 'string' || !displayAddress.startsWith('5')) {
                    // Address not valid SS58, show warning
                    displayAddress = 'Invalid address format - please create a new keystore';
                }
                document.getElementById('fundAddressDisplay').textContent = displayAddress;

                // Only enable faucet if address is valid SS58
                const validAddress = displayAddress.startsWith('5') && displayAddress.length > 40;
                document.getElementById('faucetBtn').disabled = !validAddress;
                document.getElementById('transferBtn').disabled = !validAddress;

                updateAccountStatus();
                updateWarnings();
                showResult('accountResult', 'success', 'Keystore unlocked successfully! You can now sign documents and contracts.');
            } catch (e) {
                console.error('Unlock failed:', e);
                console.error('Keystore data:', JSON.stringify(currentKeystore, null, 2));
                showResult('accountResult', 'error', 'Failed to unlock: ' + e.message + '. Please check your password and try again.');
            }
        }

        async function requestFaucetAccount() {
            if (!unlockedKey || !unlockedKey.publicKey) {
                showResult('accountResult', 'error', 'Please unlock a keystore first');
                return;
            }

            try {
                showResult('accountResult', 'success', currentLang === 'fr'
                    ? 'Envoi de 100 QMHY depuis le validateur...'
                    : 'Sending 100 QMHY from validator...');

                const result = await fundAccountDirect(unlockedKey.publicKey, 100);

                if (result && (result.success || result.hash)) {
                    showResult('accountResult', 'success', currentLang === 'fr'
                        ? `100 QMHY envoy√©s! TX: ${(result.hash || '').substring(0, 20)}...`
                        : `100 QMHY sent! TX: ${(result.hash || '').substring(0, 20)}...`);
                } else {
                    showResult('accountResult', 'error', 'Transfer failed: ' + JSON.stringify(result));
                }
            } catch (e) {
                showResult('accountResult', 'error', 'Failed to fund account: ' + e.message);
            }
        }

        async function transferTokens() {
            if (!unlockedKey) {
                showResult('accountResult', 'error', 'Please unlock a keystore first');
                return;
            }

            const recipient = document.getElementById('transferRecipient').value.trim();
            const amount = parseFloat(document.getElementById('transferAmount').value);

            if (!recipient) {
                showResult('accountResult', 'error', 'Please enter a recipient address');
                return;
            }

            if (!amount || amount <= 0) {
                showResult('accountResult', 'error', 'Please enter a valid amount');
                return;
            }

            try {
                showResult('accountResult', 'success', 'Submitting transfer...');

                // Build transfer call data
                // Balances pallet = 5, transfer_keep_alive = 3
                const BALANCES_PALLET = 5;
                const TRANSFER_CALL = 3;

                // Convert amount to smallest units (1 QMHY = 10^12 units)
                const amountUnits = BigInt(Math.floor(amount * 1e12));

                // Encode recipient (assume SS58 address)
                // For simplicity, we'll use the address as-is and let the node decode it
                const recipientHex = recipient.startsWith('0x') ? recipient.slice(2) :
                    Array.from(new TextEncoder().encode(recipient)).map(b => b.toString(16).padStart(2, '0')).join('');

                // Build call: pallet(1) + call(1) + recipient(MultiAddress) + amount(Compact<u128>)
                // This is simplified - proper implementation needs SCALE encoding
                const callData = buildTransferCallData(recipient, amountUnits);

                const signerKeyHex = typeof unlockedKey.secretKey === 'string'
                    ? unlockedKey.secretKey
                    : '0x' + Array.from(unlockedKey.secretKey).map(b => b.toString(16).padStart(2, '0')).join('');

                const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                    callData: callData,
                    signerKey: signerKeyHex.startsWith('0x') ? signerKeyHex : '0x' + signerKeyHex
                }]);

                showResult('accountResult', 'success', `Transfer submitted! Tx: ${result.hash || 'pending'}`);
                document.getElementById('transferRecipient').value = '';
                document.getElementById('transferAmount').value = '';
            } catch (e) {
                showResult('accountResult', 'error', 'Transfer failed: ' + e.message);
            }
        }

        function buildTransferCallData(recipient, amount) {
            // Balances::transfer_keep_alive = pallet 5, call 3
            // MultiAddress::Id = 0x00 + 32-byte AccountId32
            // Amount = Compact<u128>
            const palletCall = '0503'; // pallet 5, call 3

            let accountIdHex;
            if (recipient.startsWith('0x') && recipient.length === 130) {
                // 64-byte SPHINCS+ public key ‚Üí hash to 32-byte AccountId32
                accountIdHex = pubKeyToAccountId(recipient);
            } else if (recipient.startsWith('0x') && recipient.length === 66) {
                // Already a 32-byte AccountId32
                accountIdHex = recipient.slice(2);
            } else {
                throw new Error('Please use hex format (0x...) for recipient address');
            }

            const recipientEncoded = '00' + accountIdHex;
            const amountArr = encodeCompactU128(amount);
            const amountEncoded = bytesToHex(amountArr);

            return '0x' + palletCall + recipientEncoded + amountEncoded;
        }

        // Note: encodeCompactU128 is defined at ~line 5407 and returns byte array

        function lockKeystore() {
            unlockedKey = null;
            document.getElementById('keystoreInfo').style.display = 'none';
            document.getElementById('keystoreUnlockSection').style.display = 'block';
            document.getElementById('fundAddressDisplay').textContent = 'Unlock a keystore to see your address';
            document.getElementById('faucetBtn').disabled = true;
            document.getElementById('transferBtn').disabled = true;
            updateAccountStatus();
            updateWarnings();
            showResult('accountResult', 'success', 'Keystore locked. Your keys are now secured.');
        }

        async function createNewKeystore() {
            const name = document.getElementById('newKeystoreName').value.trim();
            const password = document.getElementById('newKeystorePassword').value;
            const confirm = document.getElementById('newKeystoreConfirm').value;

            if (!name) {
                showResult('accountResult', 'error', 'Please enter a name for your keystore');
                return;
            }

            if (!password || password.length < 8) {
                showResult('accountResult', 'error', 'Please enter a password of at least 8 characters');
                return;
            }

            if (password !== confirm) {
                showResult('accountResult', 'error', 'Passwords do not match. Please re-enter.');
                return;
            }

            try {
                showResult('accountResult', 'success', 'Generating SPHINCS+ key pair...');

                let keypair;
                let serverAddress = null;

                // Try to use faucet's secure keypair generation first
                try {
                    const response = await fetch(faucetBase + '/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (response.ok && contentType && contentType.includes('application/json')) {
                        const data = await response.json();
                        if (data.success && data.secret_key_hex) {
                            // Parse the 128-byte secret key (256 hex chars)
                            const secretKeyHex = data.secret_key_hex;
                            const secretKey = new Uint8Array(128);
                            for (let i = 0; i < 128; i++) {
                                secretKey[i] = parseInt(secretKeyHex.substr(i * 2, 2), 16);
                            }
                            const publicKey = secretKey.slice(64, 128);
                            keypair = { secretKey, publicKey };
                            serverAddress = data.address;
                        }
                    }
                } catch (faucetError) {
                    console.log('Faucet unavailable, using local key generation');
                }

                // Fallback to local key generation
                if (!keypair) {
                    keypair = await QHKeystore.generateKeypair();
                }

                const keystore = await QHKeystore.createKeystore(keypair, password, name);

                // Use server address if available, otherwise use generated address
                if (serverAddress) {
                    keystore.address = serverAddress;
                }

                QHKeystore.saveKeystore(keystore);

                // Clear form
                document.getElementById('newKeystoreName').value = '';
                document.getElementById('newKeystorePassword').value = '';
                document.getElementById('newKeystoreConfirm').value = '';

                loadKeystores();
                showResult('accountResult', 'success', `Keystore "${name}" created successfully!<br>Address: ${keystore.address}<br>Select it from the dropdown above to unlock.`);
            } catch (e) {
                showResult('accountResult', 'error', 'Failed to create keystore: ' + e.message);
            }
        }

        // Create account from START section (simplified flow)
        async function createAccountFromStart() {
            const name = document.getElementById('startAccountName').value.trim() || 'My Account';
            const password = document.getElementById('startPassword').value;
            const confirm = document.getElementById('startPasswordConfirm').value;

            if (!password || password.length < 8) {
                showResult('startCreateResult', 'error', 'Password must be at least 8 characters');
                return;
            }

            if (password !== confirm) {
                showResult('startCreateResult', 'error', 'Passwords do not match');
                return;
            }

            try {
                showResult('startCreateResult', 'success', 'Creating your secure account...');

                const keypair = await QHKeystore.generateKeypair();
                const keystore = await QHKeystore.createKeystore(keypair, password, name);
                QHKeystore.saveKeystore(keystore);

                // Auto-unlock ‚Äî keypair is already in memory
                currentKeystore = keystore;
                unlockedKey = {
                    secretKey: keypair.secretKey,
                    publicKey: keypair.publicKey instanceof Uint8Array
                        ? '0x' + Array.from(keypair.publicKey).map(b => b.toString(16).padStart(2, '0')).join('')
                        : keypair.publicKey
                };
                console.log('Account auto-unlocked after creation');

                // Clear form
                document.getElementById('startPassword').value = '';
                document.getElementById('startPasswordConfirm').value = '';

                // Update UI
                loadKeystores();
                updateStartSection();
                updateAccountStatus();

                showResult('startCreateResult', 'success', `Account created and unlocked! Address: ${keystore.address}`);

                // Auto-fund with 100 QMHY from validator
                try {
                    showResult('startCreateResult', 'success', `Account created! Sending 100 QMHY...`);
                    await fundAccountDirect(unlockedKey.publicKey, 100);
                    showResult('startCreateResult', 'success', `Account created, unlocked, and funded with 100 QMHY!`);
                } catch (e) {
                    console.warn('Auto-fund failed:', e.message);
                    showResult('startCreateResult', 'success', `Account created and unlocked! Use the faucet to get tokens.`);
                }
            } catch (e) {
                showResult('startCreateResult', 'error', 'Failed: ' + e.message);
            }
        }

        // Request faucet from START section
        async function requestFaucetFromStart() {
            if (!unlockedKey || !unlockedKey.publicKey) {
                showResult('faucetResult', 'error', 'No account - create one first');
                return;
            }
            try {
                showResult('faucetResult', 'success', currentLang === 'fr'
                    ? 'Envoi de 100 QMHY depuis le validateur...'
                    : 'Sending 100 QMHY from validator...');
                const result = await fundAccountDirect(unlockedKey.publicKey, 100);
                if (result && (result.success || result.hash)) {
                    showResult('faucetResult', 'success', currentLang === 'fr'
                        ? `100 QMHY envoy√©s! TX: ${(result.hash || '').substring(0, 20)}...`
                        : `100 QMHY sent! TX: ${(result.hash || '').substring(0, 20)}...`);
                } else {
                    showResult('faucetResult', 'error', 'Transfer failed: ' + JSON.stringify(result));
                }
            } catch (e) {
                showResult('faucetResult', 'error', 'Failed to fund account: ' + e.message);
            }
        }

        // Update START section based on account status
        function updateStartSection() {
            const keystores = JSON.parse(localStorage.getItem('qh_keystores') || '[]');

            if (keystores.length > 0) {
                // Has account - show success state
                document.getElementById('startNoAccount').style.display = 'none';
                document.getElementById('startHasAccount').style.display = 'block';
                document.getElementById('startAccountAddress').textContent = keystores[0].address;

                // Enable faucet
                document.getElementById('faucetAddress').value = keystores[0].address;
                document.getElementById('startFaucetBtn').disabled = false;
                document.getElementById('startCheckBalanceBtn').disabled = false;
            } else {
                // No account
                document.getElementById('startNoAccount').style.display = 'block';
                document.getElementById('startHasAccount').style.display = 'none';
                document.getElementById('faucetAddress').value = '';
                document.getElementById('startFaucetBtn').disabled = true;
                document.getElementById('startCheckBalanceBtn').disabled = true;
            }
        }

        // Call on page load
        document.addEventListener('DOMContentLoaded', updateStartSection);

        async function importSecretKey() {
            const name = document.getElementById('importKeystoreName').value.trim();
            const secretKeyHex = document.getElementById('importSecretKey').value.trim();
            const password = document.getElementById('importKeystorePassword').value;

            if (!name) {
                showResult('accountResult', 'error', 'Please enter a name for this keystore');
                return;
            }

            if (!secretKeyHex) {
                showResult('accountResult', 'error', 'Please enter your SPHINCS+ secret key');
                return;
            }

            if (!password || password.length < 8) {
                showResult('accountResult', 'error', 'Please enter a password of at least 8 characters');
                return;
            }

            try {
                // Parse the hex secret key
                const cleanHex = secretKeyHex.startsWith('0x') ? secretKeyHex.slice(2) : secretKeyHex;
                if (cleanHex.length !== 256) {
                    throw new Error(`Invalid key length: expected 256 hex chars (128 bytes), got ${cleanHex.length}`);
                }

                // Convert hex to Uint8Array
                const secretKey = new Uint8Array(128);
                for (let i = 0; i < 128; i++) {
                    secretKey[i] = parseInt(cleanHex.substr(i * 2, 2), 16);
                }

                // Derive public key (last 64 bytes - matching our keystore format)
                const publicKey = secretKey.slice(64, 128);

                const keypair = { secretKey, publicKey };
                const keystore = await QHKeystore.createKeystore(keypair, password, name);
                QHKeystore.saveKeystore(keystore);

                // Clear form
                document.getElementById('importKeystoreName').value = '';
                document.getElementById('importSecretKey').value = '';
                document.getElementById('importKeystorePassword').value = '';

                loadKeystores();
                showResult('accountResult', 'success', `Key "${name}" imported successfully! Select it from the dropdown above to unlock.`);
            } catch (e) {
                showResult('accountResult', 'error', 'Failed to import key: ' + e.message);
            }
        }

        function updateAccountStatus() {
            const btn = document.getElementById('accountStatusBtn');
            const text = document.getElementById('accountStatusText');

            if (unlockedKey) {
                btn.classList.add('success');
                btn.classList.remove('warning');
                text.textContent = 'UNLOCKED';
            } else {
                btn.classList.remove('success');
                btn.classList.add('warning');
                text.textContent = 'LOCKED';
            }

            document.getElementById('attestBtn').disabled = !unlockedKey || !selectedFileHash;
        }

        function updateAccountModalContent() {
            const content = document.getElementById('accountModalContent');
            if (unlockedKey) {
                content.innerHTML = `
                    <div style="color: var(--success); margin-bottom: 12px; font-weight: 600;">‚úì Keystore Unlocked</div>
                    <div class="data-field">
                        <div class="data-label">Your Public Key</div>
                        <div class="data-value" style="font-size: 11px;">${unlockedKey.publicKey}</div>
                    </div>
                    <p style="color: var(--muted); font-size: 13px; margin-top: 12px;">You can sign documents and contracts. Remember to lock your keystore when finished.</p>
                `;
            } else {
                content.innerHTML = `
                    <p style="color: var(--muted);">No account is currently unlocked.</p>
                    <p style="color: var(--muted); margin-top: 8px;">Go to the <strong>ACCOUNT</strong> section to create or unlock a keystore.</p>
                `;
            }
        }

        // ==================== RPC ====================
        async function rpcCall(method, params = []) {
            const response = await fetch(rpcEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
            });
            const result = await response.json();
            if (result.error) throw new Error(result.error.message);
            return result.result;
        }

        async function testConnection() {
            try {
                const chain = await rpcCall('system_chain');
                document.getElementById('nodeStatus').textContent = 'ONLINE';
                document.getElementById('statusIndicator').classList.remove('disconnected');
                document.getElementById('rpcEndpoint').textContent = rpcEndpoint.replace('http://', '').replace('https://', '');
                showResult('rpcResult', 'success', 'Connected to blockchain: ' + chain);
            } catch (e) {
                document.getElementById('nodeStatus').textContent = 'OFFLINE';
                document.getElementById('statusIndicator').classList.add('disconnected');
                showResult('rpcResult', 'error', 'Connection failed: ' + e.message);
            }
        }

        function saveRPCEndpoint() {
            rpcEndpoint = document.getElementById('rpcEndpointInput').value.trim();
            localStorage.setItem('qh_rpc_endpoint', rpcEndpoint);
            showResult('rpcResult', 'success', 'Endpoint saved. Testing connection...');
            testConnection();
        }

        // ==================== Attestation ====================
        async function submitAttestation() {
            if (!unlockedKey || !selectedFileHash) {
                showToast('warning', 'Missing Requirements', 'Please unlock keystore and select a file');
                return;
            }

            const btn = document.querySelector('#attestResult')?.closest('.lcars-display')?.querySelector('button');

            await withLoading(btn, async () => {
                try {
                    const category = parseInt(document.getElementById('attestCategory').value);
                    const storage = document.getElementById('storageOption').value;
                    const description = document.getElementById('attestDescription').value.trim();

                    showResult('attestResult', 'success', 'Submitting attestation to blockchain...');

                    // IPFS upload if selected
                    let ipfsCid = null;
                    if (storage !== 'local' && selectedFile) {
                        if (!QHIPFS.isPinataConfigured()) {
                            throw new Error('IPFS not configured. Please add your Pinata API keys in Settings first.');
                        }
                        showResult('attestResult', 'success', 'Uploading to IPFS...');
                        if (storage === 'ipfs-encrypted') {
                            const key = QHIPFS.generateEncryptionKey();
                            const result = await QHIPFS.uploadEncryptedToIPFS(selectedFile, key);
                            ipfsCid = result.cid;
                        } else {
                            const result = await QHIPFS.uploadToIPFS(selectedFile);
                            ipfsCid = result.cid;
                        }
                    }

                    // Build call data with description
                    const callData = buildAttestCallData(selectedFileHash, category, description);

                    // Convert signerKey to hex string (may be Uint8Array from keystore)
                    const signerKeyHex = typeof unlockedKey.secretKey === 'string'
                        ? unlockedKey.secretKey
                        : '0x' + Array.from(unlockedKey.secretKey).map(b => b.toString(16).padStart(2, '0')).join('');

                    // RPC expects a single object param with callData and signerKey as hex strings
                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        callData: callData,
                        signerKey: signerKeyHex.startsWith('0x') ? signerKeyHex : '0x' + signerKeyHex
                    }]);

                    // Save to history
                    saveAttestation({
                        hash: selectedFileHash,
                        fileName: selectedFile.name,
                        fileSize: selectedFile.size,
                        category: category,
                        ipfsCid: ipfsCid,
                        timestamp: new Date().toISOString(),
                        blockHash: result.blockHash
                    });

                    loadAttestationHistory();
                    showResult('attestResult', 'success', `
                        <strong>Attestation Successful!</strong><br><br>
                        Your document has been permanently recorded on the QuantumHarmony blockchain.<br><br>
                        <strong>Document Hash:</strong> ${selectedFileHash.substring(0, 20)}...<br>
                        ${ipfsCid ? `<strong>IPFS CID:</strong> ${ipfsCid}<br>` : ''}
                        <strong>Block:</strong> ${result.blockHash || 'Pending confirmation'}
                    `);

                    showToast('success', 'Attestation Complete', 'Document recorded on blockchain');

                } catch (e) {
                    showResult('attestResult', 'error', 'Attestation failed: ' + e.message);
                    showToast('error', 'Attestation Failed', e.message);
                }
            });
        }

        function buildAttestCallData(hash, category, description = '') {
            const hashBytes = hash.startsWith('0x') ? hash.slice(2) : hash;

            // SCALE encode the description as Vec<u8>
            const descBytes = new TextEncoder().encode(description);
            const descLenEncoded = encodeCompactU32(descBytes.length);
            const descHex = descLenEncoded + Array.from(descBytes).map(b => b.toString(16).padStart(2, '0')).join('');

            // Build call: pallet(1) + call(1) + hash(32) + category(1) + description(Vec) + validity(Option) + contract_id(Option) + academic_id(Option)
            return `0x${NOTARIAL_PALLET_INDEX.toString(16).padStart(2, '0')}00${hashBytes}${category.toString(16).padStart(2, '0')}${descHex}000000`;
        }

        // SCALE compact encoding for u32
        function encodeCompactU32(value) {
            if (value < 64) {
                return (value << 2).toString(16).padStart(2, '0');
            } else if (value < 16384) {
                const encoded = (value << 2) | 0x01;
                return encoded.toString(16).padStart(4, '0').match(/.{2}/g).reverse().join('');
            } else if (value < 1073741824) {
                const encoded = (value << 2) | 0x02;
                return encoded.toString(16).padStart(8, '0').match(/.{2}/g).reverse().join('');
            } else {
                throw new Error('Value too large for compact encoding');
            }
        }

        // ==================== On-Chain Storage Queries (Ricardian Contracts) ====================

        // Pre-computed twox_128 hashes for Substrate storage key construction
        // Generated via: xxhash64(name, seed=0) || xxhash64(name, seed=1) in LE bytes
        const TWOX128 = {
            'RicardianContracts': '4cc7ebc9a4839023e25c2c0e253fb8b9',
            'Contracts':          '4342193e496fab7ec59d615ed0dc5530',
            'Parties':            '6cb76a9e23205a61fba0be176e013ef2',
            'NextContractId':     '1bc2c9d3ca89ca47253bfa89e657f260',
        };

        // Blake2 128 concat hasher for storage key maps
        function blake2_128_concat(input) {
            const bytes = typeof input === 'string'
                ? new TextEncoder().encode(input)
                : (input instanceof Uint8Array ? input : new Uint8Array(input));
            // blake2b 128-bit = 16 bytes
            const hash = blakejs.blake2b(bytes, null, 16);
            const hashHex = Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join('');
            const inputHex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex + inputHex;
        }

        // Encode u32 as 4-byte LE for storage key
        function u32ToLeBytes(value) {
            return new Uint8Array([value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff]);
        }

        function buildContractStorageKey(contractId) {
            const prefix = TWOX128['RicardianContracts'] + TWOX128['Contracts'];
            const keySuffix = blake2_128_concat(u32ToLeBytes(contractId));
            return '0x' + prefix + keySuffix;
        }

        function buildPartiesStorageKey(contractId) {
            const prefix = TWOX128['RicardianContracts'] + TWOX128['Parties'];
            const keySuffix = blake2_128_concat(u32ToLeBytes(contractId));
            return '0x' + prefix + keySuffix;
        }

        function buildNextContractIdKey() {
            return '0x' + TWOX128['RicardianContracts'] + TWOX128['NextContractId'];
        }

        async function queryStorage(key) {
            return await rpcCall('state_getStorage', [key]);
        }

        // SCALE decode Contract struct from hex
        function decodeContract(hex) {
            if (!hex) return null;
            const data = hex.startsWith('0x') ? hex.slice(2) : hex;
            let offset = 0;

            function readBytes(n) {
                const slice = data.slice(offset, offset + n * 2);
                offset += n * 2;
                return slice;
            }
            function readU32() {
                const b = readBytes(4);
                return parseInt(b.slice(6, 8) + b.slice(4, 6) + b.slice(2, 4) + b.slice(0, 2), 16);
            }
            function readU8() {
                return parseInt(readBytes(1), 16);
            }
            function readCompactU32() {
                const first = readU8();
                const mode = first & 0x03;
                if (mode === 0) return first >> 2;
                if (mode === 1) { const second = readU8(); return ((second << 8) | first) >> 2; }
                if (mode === 2) { const b1 = readU8(), b2 = readU8(), b3 = readU8(); return ((b3 << 24) | (b2 << 16) | (b1 << 8) | first) >> 2; }
                throw new Error('Big integer compact not supported here');
            }
            function readVecU8() {
                const len = readCompactU32();
                const bytes = [];
                for (let i = 0; i < len; i++) bytes.push(readU8());
                return new TextDecoder().decode(new Uint8Array(bytes));
            }
            function readAccountId() {
                return '0x' + readBytes(32); // 32-byte AccountId32 (Keccak-256 of SPHINCS+ key)
            }
            function readOptionU32() {
                const tag = readU8();
                if (tag === 0) return null;
                return readU32();
            }

            const id = readU32();
            const title = readVecU8();
            const contractType = readU8(); // enum variant
            const status = readU8(); // enum variant
            const creator = readAccountId();
            const createdAt = readU32();
            const expiresAt = readOptionU32();
            const documentHash = '0x' + readBytes(32);
            const partyCount = readU32();
            const signaturesCollected = readU32();
            const termCount = readU32();
            const amendmentCount = readU32();
            const academicProgramId = readOptionU32();

            const types = ['Academic Program', 'Partnership', 'Service', 'NDA', 'Employment', 'License', 'Custom'];
            const statuses = ['Draft', 'Active', 'Executed', 'Terminated', 'Expired'];

            return {
                id, title,
                contractType: types[contractType] || 'Unknown',
                contractTypeId: contractType,
                status: statuses[status] || 'Unknown',
                statusId: status,
                creator, createdAt, expiresAt,
                documentHash, partyCount, signaturesCollected,
                termCount, amendmentCount, academicProgramId
            };
        }

        // SCALE decode Vec<Party> from hex
        function decodeParties(hex) {
            if (!hex) return [];
            const data = hex.startsWith('0x') ? hex.slice(2) : hex;
            let offset = 0;

            function readBytes(n) {
                const slice = data.slice(offset, offset + n * 2);
                offset += n * 2;
                return slice;
            }
            function readU32() {
                const b = readBytes(4);
                return parseInt(b.slice(6, 8) + b.slice(4, 6) + b.slice(2, 4) + b.slice(0, 2), 16);
            }
            function readU8() { return parseInt(readBytes(1), 16); }
            function readCompactU32() {
                const first = readU8();
                const mode = first & 0x03;
                if (mode === 0) return first >> 2;
                if (mode === 1) { const second = readU8(); return ((second << 8) | first) >> 2; }
                if (mode === 2) { const b1 = readU8(), b2 = readU8(), b3 = readU8(); return ((b3 << 24) | (b2 << 16) | (b1 << 8) | first) >> 2; }
                throw new Error('Big integer compact not supported here');
            }
            function readVecU8() {
                const len = readCompactU32();
                const bytes = [];
                for (let i = 0; i < len; i++) bytes.push(readU8());
                return new TextDecoder().decode(new Uint8Array(bytes));
            }
            function readAccountId() { return '0x' + readBytes(32); }
            function readBool() { return readU8() !== 0; }
            function readOptionU32() {
                const tag = readU8();
                if (tag === 0) return null;
                return readU32();
            }

            // BoundedVec<Party> is encoded as Vec<Party>
            const count = readCompactU32();
            const parties = [];
            for (let i = 0; i < count; i++) {
                parties.push({
                    account: readAccountId(),
                    role: readVecU8(),
                    signed: readBool(),
                    signedAt: readOptionU32()
                });
            }
            return parties;
        }

        function decodeNextContractId(hex) {
            if (!hex) return 0;
            const data = hex.startsWith('0x') ? hex.slice(2) : hex;
            // u32 LE
            return parseInt(data.slice(6, 8) + data.slice(4, 6) + data.slice(2, 4) + data.slice(0, 2), 16);
        }

        // ==================== Ricardian Pallet Call Encoder ====================

        function buildRicardianCall(callIndex, params) {
            let callData = [RICARDIAN_PALLET_INDEX, callIndex];

            switch (callIndex) {
                case 0: { // create_contract(title: Vec<u8>, contract_type_id: u8, document_hash: [u8;32], expires_at: Option<u32>, academic_program_id: Option<u32>)
                    const titleBytes = new TextEncoder().encode(params.title);
                    // Vec<u8> prefix: compact length
                    const titleLen = [];
                    if (titleBytes.length < 64) titleLen.push(titleBytes.length << 2);
                    else if (titleBytes.length < 16384) { const v = (titleBytes.length << 2) | 1; titleLen.push(v & 0xff, (v >> 8) & 0xff); }
                    callData.push(...titleLen, ...titleBytes);
                    // contract_type_id: u8
                    callData.push(params.contractTypeId);
                    // document_hash: [u8; 32]
                    const hashBytes = hexToBytes(params.documentHash);
                    callData.push(...hashBytes);
                    // expires_at: Option<u32>
                    if (params.expiresAt != null) {
                        callData.push(1);
                        const e = params.expiresAt;
                        callData.push(e & 0xff, (e >> 8) & 0xff, (e >> 16) & 0xff, (e >> 24) & 0xff);
                    } else {
                        callData.push(0);
                    }
                    // academic_program_id: Option<u32>
                    if (params.academicProgramId != null) {
                        callData.push(1);
                        const a = params.academicProgramId;
                        callData.push(a & 0xff, (a >> 8) & 0xff, (a >> 16) & 0xff, (a >> 24) & 0xff);
                    } else {
                        callData.push(0);
                    }
                    break;
                }
                case 1: { // add_party(contract_id: u32, party_account: AccountId32, role: Vec<u8>)
                    const cid = params.contractId;
                    callData.push(cid & 0xff, (cid >> 8) & 0xff, (cid >> 16) & 0xff, (cid >> 24) & 0xff);
                    // party_account: 32-byte AccountId32 = Keccak-256(64-byte SPHINCS+ pubkey)
                    const partyAccountId = pubKeyToAccountId(params.partyAccount);
                    callData.push(...hexToBytes(partyAccountId));
                    // role: Vec<u8>
                    const roleBytes = new TextEncoder().encode(params.role);
                    const roleLen = [];
                    if (roleBytes.length < 64) roleLen.push(roleBytes.length << 2);
                    else if (roleBytes.length < 16384) { const v = (roleBytes.length << 2) | 1; roleLen.push(v & 0xff, (v >> 8) & 0xff); }
                    callData.push(...roleLen, ...roleBytes);
                    break;
                }
                case 3: { // sign_contract(contract_id: u32)
                    const cid = params.contractId;
                    callData.push(cid & 0xff, (cid >> 8) & 0xff, (cid >> 16) & 0xff, (cid >> 24) & 0xff);
                    break;
                }
            }

            return '0x' + callData.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Helper: get signer key as hex string
        function getSignerKeyHex() {
            if (!unlockedKey) return null;
            return typeof unlockedKey.secretKey === 'string'
                ? (unlockedKey.secretKey.startsWith('0x') ? unlockedKey.secretKey : '0x' + unlockedKey.secretKey)
                : '0x' + Array.from(unlockedKey.secretKey).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Helper: submit a signed extrinsic (optional explicit nonce)
        async function submitExtrinsic(callData, nonce) {
            const signerKeyHex = getSignerKeyHex();
            if (!signerKeyHex) throw new Error('No account unlocked');
            const req = {
                callData: callData,
                signerKey: signerKeyHex
            };
            if (nonce !== undefined) req.nonce = nonce;
            return await rpcCall('quantumharmony_submitSignedExtrinsic', [req]);
        }

        // ==================== Contract Document Upload ====================
        let contractDocumentHash = null;

        function setupContractDocDropZone() {
            const zone = document.getElementById('contractDocDropZone');
            const input = document.getElementById('contractDocFile');
            if (!zone || !input) return;

            zone.addEventListener('click', () => input.click());
            zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.style.borderColor = 'var(--accent)'; });
            zone.addEventListener('dragleave', () => { zone.style.borderColor = 'var(--border)'; });
            zone.addEventListener('drop', async (e) => {
                e.preventDefault();
                zone.style.borderColor = 'var(--border)';
                if (e.dataTransfer.files.length) await handleContractDoc(e.dataTransfer.files[0]);
            });
            input.addEventListener('change', async (e) => {
                if (e.target.files.length) await handleContractDoc(e.target.files[0]);
            });
        }

        async function handleContractDoc(file) {
            contractDocumentHash = await hashFile(file);
            document.getElementById('contractDocFileName').textContent = `${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('contractDocHash').textContent = 'SHA-256: ' + contractDocumentHash;
            document.getElementById('contractDocInfo').style.display = 'block';
            document.getElementById('contractDocDropZone').style.display = 'none';
            // Show IPFS storage option
            document.getElementById('contractStorageField').style.display = 'block';
            checkContractIPFSConfig();
        }

        function clearContractDoc() {
            contractDocumentHash = null;
            document.getElementById('contractDocInfo').style.display = 'none';
            document.getElementById('contractDocDropZone').style.display = 'block';
            document.getElementById('contractDocFile').value = '';
            document.getElementById('contractStorageField').style.display = 'none';
        }

        function saveAttestation(attestation) {
            const history = JSON.parse(localStorage.getItem('qh_attestation_history') || '[]');
            history.unshift(attestation);
            localStorage.setItem('qh_attestation_history', JSON.stringify(history.slice(0, 100)));
        }

        function loadAttestationHistory() {
            const history = JSON.parse(localStorage.getItem('qh_attestation_history') || '[]');
            const container = document.getElementById('attestationHistory');

            if (history.length === 0) {
                container.innerHTML = '<div style="color: var(--muted); padding: 20px; text-align: center;">No attestations yet. Attest your first document above.</div>';
                return;
            }

            const categories = ['Academic', 'Legal', 'Contract', 'IP', 'Identity', 'Financial', 'Medical', 'Other'];

            container.innerHTML = history.map(a => `
                <div class="history-item">
                    <div>
                        <div style="color: var(--text); font-weight: 500;">${a.fileName || 'Unknown file'}</div>
                        <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
                            ${a.hash.substring(0, 24)}... | ${categories[a.category] || 'Unknown'}
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 12px; color: var(--muted);">${new Date(a.timestamp).toLocaleDateString()}</div>
                        <div style="font-size: 11px; color: var(--muted);">${new Date(a.timestamp).toLocaleTimeString()}</div>
                    </div>
                </div>
            `).join('');
        }

        // ==================== Verification ====================
        async function verifyDocument() {
            const hash = document.getElementById('verifyHash').value.trim();
            if (!hash) {
                showToast('warning', 'No Document', 'Please upload a document or enter a hash');
                showResult('verifyResult', 'error', 'Please upload a document or enter a hash to verify');
                return;
            }

            if (!hash.startsWith('0x') || hash.length !== 66) {
                showToast('error', 'Invalid Hash', 'Must be 0x followed by 64 hex characters');
                showResult('verifyResult', 'error', 'Invalid hash format. Hash should be 0x followed by 64 hex characters.');
                return;
            }

            const btn = document.querySelector('#verifyResult')?.closest('.lcars-display')?.querySelector('button');

            await withLoading(btn, async () => {
                try {
                    showResult('verifyResult', 'success', 'Searching blockchain for attestation...');

                    const result = await rpcCall('notarial_verifyDocument', [hash]);

                    if (result && result.exists) {
                        const categories = ['Academic', 'Legal', 'Contract', 'IP', 'Identity', 'Financial', 'Medical', 'Other'];
                        showResult('verifyResult', 'success', `
                            <strong>‚úì Document Verified!</strong><br><br>
                            This document was attested on the QuantumHarmony blockchain.<br><br>
                            <strong>Attester:</strong> ${result.attester.substring(0, 20)}...<br>
                            <strong>Block Number:</strong> ${result.blockNumber}<br>
                            <strong>Category:</strong> ${categories[result.category] || 'Unknown'}<br>
                            <strong>Timestamp:</strong> ${result.timestamp || 'N/A'}
                        `);
                        showToast('success', 'Document Verified', 'Found on blockchain');
                    } else {
                        showResult('verifyResult', 'error', 'Document not found on blockchain. This document has not been attested, or the hash does not match any records.');
                        showToast('warning', 'Not Found', 'Document not on blockchain');
                    }
                } catch (e) {
                    showResult('verifyResult', 'error', 'Verification failed: ' + e.message);
                    showToast('error', 'Verification Failed', e.message);
                }
            });
        }

        // ==================== Contracts ====================
        function wizardStep2() {
            const title = document.getElementById('contractTitle').value.trim();
            const description = document.getElementById('contractDescription').value.trim();

            if (!title) {
                showToast('warning', 'Missing Title', 'Please enter a contract title');
                return;
            }
            if (!description) {
                showToast('warning', 'Missing Terms', 'Please enter contract terms/description');
                return;
            }

            document.getElementById('wizardStep1').style.display = 'none';
            document.getElementById('wizardStep2').style.display = 'block';
        }

        function wizardBack1() {
            document.getElementById('wizardStep2').style.display = 'none';
            document.getElementById('wizardStep1').style.display = 'block';
        }

        function wizardBack2() {
            document.getElementById('wizardStep3').style.display = 'none';
            document.getElementById('wizardStep2').style.display = 'block';
        }

        function wizardStep3() {
            if (contractParties.length < 2) {
                showToast('warning', 'More Parties Needed', 'Please add at least 2 parties');
                return;
            }
            document.getElementById('wizardStep2').style.display = 'none';
            document.getElementById('wizardStep3').style.display = 'block';

            const title = document.getElementById('contractTitle').value;
            const typeSelect = document.getElementById('contractType');
            const type = typeSelect.options[typeSelect.selectedIndex].text;
            const desc = document.getElementById('contractDescription').value;

            document.getElementById('contractSummary').innerHTML = `
                <div class="data-field">
                    <div class="data-label">Contract Title</div>
                    <div class="data-value" style="font-family: inherit;">${title}</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Type</div>
                    <div class="data-value" style="font-family: inherit;">${type}</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Terms</div>
                    <div class="data-value" style="font-family: inherit; white-space: pre-wrap;">${desc}</div>
                </div>
                <div class="data-field">
                    <div class="data-label">Parties (${contractParties.length})</div>
                    <div class="data-value" style="font-family: inherit;">
                        ${contractParties.map(p => `‚Ä¢ ${p.name}`).join('<br>')}
                    </div>
                </div>
            `;
        }

        function addParty() {
            const name = document.getElementById('partyName').value.trim();
            const address = document.getElementById('partyAddress').value.trim();

            if (!name) {
                showToast('warning', 'Missing Name', 'Please enter the party name');
                return;
            }
            if (!address || !address.startsWith('0x')) {
                showToast('error', 'Invalid Key', 'Please enter a valid public key (0x...)');
                return;
            }

            contractParties.push({ name, address });
            document.getElementById('partyName').value = '';
            document.getElementById('partyAddress').value = '';
            updatePartiesList();
            showToast('success', 'Party Added', name);
        }

        function updatePartiesList() {
            const container = document.getElementById('partiesList');
            if (contractParties.length === 0) {
                container.innerHTML = '<span style="color: var(--muted);">No parties added yet</span>';
                return;
            }

            container.innerHTML = contractParties.map((p, i) => `
                <div style="padding: 10px; background: var(--bg); border: 1px solid var(--border); margin: 6px 0; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: var(--text);">${p.name}</strong><br>
                        <span style="font-size: 11px; color: var(--muted); font-family: monospace;">${p.address.substring(0, 24)}...</span>
                    </div>
                    <button onclick="removeParty(${i})" style="background: var(--error); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">Remove</button>
                </div>
            `).join('');
        }

        function removeParty(index) {
            contractParties.splice(index, 1);
            updatePartiesList();
        }

        async function createContract() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore first');
                return;
            }

            const title = document.getElementById('contractTitle').value.trim();
            const contractTypeId = parseInt(document.getElementById('contractType').value);
            const description = document.getElementById('contractDescription').value.trim();

            if (!title) {
                showToast('warning', 'Missing Title', 'Please enter a contract title');
                return;
            }

            if (contractParties.length < 2) {
                showToast('warning', 'Need Parties', 'Please add at least 2 parties');
                return;
            }

            try {
                showToast('info', 'Submitting...', 'Creating contract on blockchain');

                // Use document hash if uploaded, otherwise hash the description text
                let docHash = contractDocumentHash;
                if (!docHash) {
                    const descBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(description));
                    docHash = '0x' + Array.from(new Uint8Array(descBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
                }

                // Query NextContractId to predict the on-chain ID
                let predictedId;
                try {
                    const nextIdHex = await queryStorage(buildNextContractIdKey());
                    predictedId = nextIdHex ? decodeNextContractId(nextIdHex) : 0;
                } catch (e) {
                    predictedId = 0; // First contract
                }

                // 1. Submit create_contract extrinsic
                const createCallData = buildRicardianCall(0, {
                    title: title,
                    contractTypeId: contractTypeId,
                    documentHash: docHash,
                    expiresAt: null,
                    academicProgramId: null
                });

                console.log('createContract: step 1 - create_contract');
                const createResult = await submitExtrinsic(createCallData);
                const baseNonce = createResult.nonce !== undefined ? createResult.nonce : 0;
                console.log('createContract: step 1 done, nonce:', baseNonce);

                // 2. Add each party (explicit nonces to avoid race conditions)
                for (let i = 0; i < contractParties.length; i++) {
                    const party = contractParties[i];
                    const partyNonce = baseNonce + 1 + i;

                    const addPartyCallData = buildRicardianCall(1, {
                        contractId: predictedId,
                        partyAccount: party.address,
                        role: party.name
                    });

                    console.log(`createContract: step 2.${i} - add_party nonce:${partyNonce}`);
                    await submitExtrinsic(addPartyCallData, partyNonce);
                    console.log(`createContract: step 2.${i} complete`);
                }

                // 3. IPFS upload if document attached and IPFS storage selected
                let ipfsCid = null;
                let ipfsEncryptionKey = null;
                const contractDocFile = document.getElementById('contractDocFile').files[0];
                if (contractDocFile && document.getElementById('contractStorageField').style.display !== 'none') {
                    const storage = document.getElementById('contractStorageOption').value;
                    if (storage !== 'local') {
                        if (!QHIPFS.isPinataConfigured()) {
                            showToast('error', 'IPFS Not Configured', 'Add Pinata API keys in Settings first');
                            return;
                        }
                        showToast('info', 'Uploading', 'Uploading document to IPFS...');
                        if (storage === 'ipfs-encrypted') {
                            const keyBytes = QHIPFS.generateEncryptionKey();
                            const result = await QHIPFS.uploadEncryptedToIPFS(contractDocFile, keyBytes);
                            ipfsCid = result.cid;
                            ipfsEncryptionKey = QHIPFS.base64urlEncode(keyBytes);
                        } else {
                            const result = await QHIPFS.uploadToIPFS(contractDocFile);
                            ipfsCid = result.cid;
                        }
                    }
                }

                // 4. Save locally for reference
                const contract = {
                    id: String(predictedId),
                    onChainId: predictedId,
                    title,
                    type: contractTypeId,
                    description,
                    documentHash: docHash,
                    documentName: contractDocFile ? contractDocFile.name : null,
                    ipfsCid: ipfsCid,
                    encryptionKey: ipfsEncryptionKey,
                    parties: contractParties,
                    status: 'draft',
                    signatures: [],
                    createdAt: new Date().toISOString(),
                    creator: unlockedKey.publicKey,
                    txHash: createResult.hash || createResult.tx_hash || null
                };
                saveContract(contract);
                loadContracts();
                closeModal('createContractModal');

                // 5. Show signing link modal
                const baseUrl = window.location.origin + window.location.pathname;
                let signingUrl = baseUrl + '#sign/' + predictedId;
                if (ipfsCid) {
                    signingUrl += '/' + ipfsCid;
                    if (ipfsEncryptionKey) signingUrl += '/' + ipfsEncryptionKey;
                }

                document.getElementById('signingLinkContractId').textContent = '#' + predictedId;
                document.getElementById('signingLinkUrl').value = signingUrl;
                document.getElementById('signingLinkModal').classList.add('active');

                showToast('success', 'Contract Created', `On-chain ID: ${predictedId}`);

                // Reset
                contractDocumentHash = null;

            } catch (e) {
                showToast('error', 'Contract Creation Failed', e.message);
            }
        }

        function saveContract(contract) {
            const contracts = JSON.parse(localStorage.getItem('qh_contracts') || '[]');
            contracts.unshift(contract);
            localStorage.setItem('qh_contracts', JSON.stringify(contracts));
        }

        function loadContracts() {
            const contracts = JSON.parse(localStorage.getItem('qh_contracts') || '[]');
            const grid = document.getElementById('contractsGrid');

            if (contracts.length === 0) {
                grid.innerHTML = '<div style="color: var(--muted); padding: 20px;">No contracts yet. Create your first contract above.</div>';
                return;
            }

            const types = ['Academic', 'Partnership', 'Service', 'NDA', 'Employment', 'License', 'Custom'];

            grid.innerHTML = contracts.map(c => {
                const isOnChain = c.onChainId != null;
                const displayId = isOnChain ? `#${c.onChainId} (on-chain)` : c.id;
                const signingLink = isOnChain
                    ? `<div style="margin-top: 6px;"><button onclick="showContractSigningLink(${c.onChainId})" style="background: var(--accent); border: none; color: #000; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">Copy Signing Link</button></div>`
                    : '';
                return `
                <div class="contract-card">
                    <h3>${c.title}</h3>
                    <div class="meta">
                        ID: ${displayId}<br>
                        Type: ${types[c.type] || 'Unknown'}<br>
                        Created: ${new Date(c.createdAt).toLocaleDateString()}
                    </div>
                    <div class="status ${c.status}">${c.status}</div>
                    <div class="meta" style="margin-top: 8px;">
                        ${c.parties.length} parties ‚Ä¢ ${c.signatures?.length || 0}/${c.parties.length} signatures
                    </div>
                    ${signingLink}
                </div>`;
            }).join('');
        }

        function showContractSigningLink(onChainId) {
            const baseUrl = window.location.origin + window.location.pathname;
            const signingUrl = baseUrl + '#sign/' + onChainId;
            document.getElementById('signingLinkContractId').textContent = '#' + onChainId;
            document.getElementById('signingLinkUrl').value = signingUrl;
            document.getElementById('signingLinkModal').classList.add('active');
        }

        async function signContract() {
            const contractIdStr = document.getElementById('signContractId').value.trim();
            if (!contractIdStr) {
                showToast('warning', 'No Contract ID', 'Please enter a contract ID');
                showResult('signResult', 'error', 'Please enter a contract ID');
                return;
            }

            if (!unlockedKey) {
                showResult('signResult', 'error', 'Please unlock your keystore first.');
                return;
            }

            const contractId = parseInt(contractIdStr);
            if (isNaN(contractId)) {
                showResult('signResult', 'error', 'Contract ID must be a number (on-chain ID).');
                return;
            }

            const btn = document.querySelector('#signContractModal .action-button');

            await withLoading(btn, async () => {
                try {
                    showResult('signResult', 'success', 'Submitting signature to blockchain...');

                    // Submit sign_contract extrinsic on-chain
                    const callData = buildRicardianCall(3, { contractId: contractId });
                    const result = await submitExtrinsic(callData);

                    // Also try to fetch updated contract state
                    let statusText = 'Signature submitted';
                    try {
                        await new Promise(r => setTimeout(r, 2000)); // Wait for block
                        const contractHex = await queryStorage(buildContractStorageKey(contractId));
                        if (contractHex) {
                            const contract = decodeContract(contractHex);
                            statusText = `Status: ${contract.status} (${contract.signaturesCollected}/${contract.partyCount} signed)`;
                        }
                    } catch (e) { /* query failed, that's ok */ }

                    showResult('signResult', 'success', `
                        <strong>Contract Signed On-Chain!</strong><br><br>
                        Your SPHINCS+ signature has been permanently recorded on the QuantumHarmony blockchain.<br><br>
                        <strong>Contract ID:</strong> ${contractId}<br>
                        <strong>${statusText}</strong><br>
                        <strong>Transaction:</strong> ${result.hash || result.tx_hash || 'submitted'}
                    `);
                    showToast('success', 'Signed On-Chain', `Contract #${contractId}`);
                    loadContracts();

                } catch (e) {
                    showResult('signResult', 'error', 'Failed to sign contract: ' + e.message);
                    showToast('error', 'Signing Failed', e.message);
                }
            });
        }

        async function viewContract() {
            const contractIdStr = document.getElementById('viewContractId').value.trim();
            if (!contractIdStr) {
                showToast('warning', 'No Contract ID', 'Please enter a contract ID');
                return;
            }

            const contractId = parseInt(contractIdStr);
            if (isNaN(contractId)) {
                // Fall back to localStorage lookup for old-style IDs
                const contracts = JSON.parse(localStorage.getItem('qh_contracts') || '[]');
                const contract = contracts.find(c => c.id === contractIdStr);
                if (contract) {
                    document.getElementById('viewTitle').textContent = contract.title;
                    document.getElementById('viewStatus').innerHTML = `<span class="status ${contract.status}" style="padding: 2px 8px;">${contract.status.toUpperCase()}</span>`;
                    document.getElementById('viewParties').innerHTML = contract.parties.map(p => `&bull; ${p.name}`).join('<br>');
                    document.getElementById('contractDetails').style.display = 'block';
                } else {
                    showToast('error', 'Not Found', 'Contract not found locally or on-chain');
                }
                return;
            }

            try {
                showToast('info', 'Querying...', 'Fetching contract from blockchain');

                const [contractHex, partiesHex] = await Promise.all([
                    queryStorage(buildContractStorageKey(contractId)),
                    queryStorage(buildPartiesStorageKey(contractId))
                ]);

                if (!contractHex) {
                    showToast('error', 'Not Found', `Contract #${contractId} not found on-chain`);
                    return;
                }

                const contract = decodeContract(contractHex);
                const parties = decodeParties(partiesHex);

                document.getElementById('viewTitle').textContent = contract.title;
                document.getElementById('viewStatus').innerHTML = `<span style="padding: 2px 8px; background: var(--${contract.statusId === 0 ? 'warning' : contract.statusId === 1 ? 'navy-light' : 'success'}); color: white; border-radius: 4px; font-size: 12px;">${contract.status.toUpperCase()}</span>`;

                const partiesHtml = parties.map(p => {
                    const signed = p.signed ? '<span style="color: var(--success);">(signed)</span>' : '<span style="color: var(--warning);">(pending)</span>';
                    return `&bull; ${p.role} ‚Äî ${p.account.substring(0, 20)}... ${signed}`;
                }).join('<br>');
                document.getElementById('viewParties').innerHTML = partiesHtml;

                document.getElementById('viewSignatures').innerHTML = `
                    <strong>Type:</strong> ${contract.contractType}<br>
                    <strong>Signatures:</strong> ${contract.signaturesCollected}/${contract.partyCount}<br>
                    <strong>Document Hash:</strong> <span style="font-size: 10px; font-family: monospace;">${contract.documentHash}</span><br>
                    <strong>Created at block:</strong> ${contract.createdAt}
                `;

                document.getElementById('contractDetails').style.display = 'block';
                showToast('success', 'Contract Loaded', `#${contractId}: ${contract.title}`);

            } catch (e) {
                showToast('error', 'Query Failed', e.message);
            }
        }

        // ==================== URL Routing for Signing Links ====================

        function checkSigningRoute() {
            const hash = window.location.hash;
            // Match: #sign/<id>  or  #sign/<id>/<cid>  or  #sign/<id>/<cid>/<key>
            const match = hash.match(/^#sign\/(\d+)(?:\/([^\/]+))?(?:\/([^\/]+))?$/);
            if (match) {
                const contractId = parseInt(match[1]);
                const ipfsCid = match[2] || null;
                const encryptionKey = match[3] || null;
                showSigningFlow(contractId, ipfsCid, encryptionKey);
            }
        }

        window.addEventListener('hashchange', checkSigningRoute);

        // ==================== Signing Flow (6-Phase Notarial Experience) ====================

        let signingFlowContractId = null;
        let signingFlowContract = null;
        let signingFlowParties = null;
        let signingKeysDisplayedNotDestroyed = false;

        // --- Session Persistence ---
        function getSigningSession(contractId) {
            try {
                const sessions = JSON.parse(localStorage.getItem('qh_signing_sessions') || '{}');
                return sessions['contract_' + contractId] || null;
            } catch (e) { return null; }
        }

        function saveSigningSession(contractId, data) {
            try {
                const sessions = JSON.parse(localStorage.getItem('qh_signing_sessions') || '{}');
                sessions['contract_' + contractId] = { ...(sessions['contract_' + contractId] || {}), ...data };
                localStorage.setItem('qh_signing_sessions', JSON.stringify(sessions));
            } catch (e) { console.warn('saveSigningSession:', e); }
        }

        // --- Phase Visibility Helper ---
        function hideAllSigningPhases() {
            ['signingPhaseLoading', 'signingPhaseKYC', 'signingPhaseReview',
             'signingPhaseSignature', 'signingPhaseKeys', 'signingPhaseComplete'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
        }

        // --- Populate Review Phase from chain data ---
        function populateReviewPhase() {
            document.getElementById('signingContractTitle').textContent = signingFlowContract.title;
            document.getElementById('signingContractType').textContent = signingFlowContract.contractType;

            const statusColors = { Draft: 'var(--warning)', Active: 'var(--navy-light)', Executed: 'var(--success)', Terminated: 'var(--error)', Expired: 'var(--muted)' };
            document.getElementById('signingContractStatus').innerHTML = `<span style="color: ${statusColors[signingFlowContract.status] || 'var(--muted)'}; font-weight: bold;">${signingFlowContract.status.toUpperCase()}</span> ‚Äî ${signingFlowContract.signaturesCollected}/${signingFlowContract.partyCount} signed`;
            document.getElementById('signingDocHash').textContent = signingFlowContract.documentHash;

            const partiesEl = document.getElementById('signingPartiesList');
            partiesEl.innerHTML = signingFlowParties.map(p => {
                const icon = p.signed ? '<span style="color: var(--success);">&#10003;</span>' : '<span style="color: var(--warning);">&#9679;</span>';
                const status = p.signed ? `Signed (block #${p.signedAt})` : 'Awaiting signature';
                return `<div style="padding: 8px; background: var(--bg); border: 1px solid var(--border); margin: 4px 0; border-radius: 6px;">
                    ${icon} <strong>${p.role}</strong><br>
                    <span style="font-size: 10px; color: var(--muted); font-family: monospace;">${p.account.substring(0, 24)}...</span><br>
                    <span style="font-size: 11px; color: ${p.signed ? 'var(--success)' : 'var(--warning)'};">${status}</span>
                </div>`;
            }).join('');

            setupSigningVerifyDropZone();
        }

        // --- Phase 1: KYC ---
        function submitKYC() {
            const fullName = document.getElementById('kycFullName').value.trim();
            const email = document.getElementById('kycEmail').value.trim();
            const phone = document.getElementById('kycPhone').value.trim();
            const address = document.getElementById('kycAddress').value.trim();
            const dateOfBirth = document.getElementById('kycDateOfBirth').value;

            if (!fullName) { showResult('kycResult', 'error', 'Full legal name is required.'); return; }
            if (!email || !email.includes('@')) { showResult('kycResult', 'error', 'A valid email address is required.'); return; }
            if (!address) { showResult('kycResult', 'error', 'Mailing address is required.'); return; }
            if (!dateOfBirth) { showResult('kycResult', 'error', 'Date of birth is required.'); return; }

            saveSigningSession(signingFlowContractId, {
                kyc: { fullName, email, phone, address, dateOfBirth, completedAt: new Date().toISOString() },
                currentPhase: 'review'
            });

            // Transition to review
            hideAllSigningPhases();
            populateReviewPhase();
            document.getElementById('signingPhaseReview').style.display = 'block';
            showToast('success', 'Identity Registered', 'You can now review the contract.');

            // Fetch IPFS document if available
            if (signingFlowIpfsCid) {
                fetchAndDisplayIPFSDocument(signingFlowIpfsCid, signingFlowEncryptionKey);
            }
        }

        // --- Phase 2 ‚Üí 3: Show signature phase ---
        function showSignaturePhase() {
            hideAllSigningPhases();
            document.getElementById('signingPhaseSignature').style.display = 'block';
            initSignaturePad();
        }

        // --- Download Contract Summary ---
        function downloadContractSummary() {
            const session = getSigningSession(signingFlowContractId);
            const kyc = session?.kyc || {};
            const c = signingFlowContract;
            const lines = [
                '=== QuantumHarmony Contract Summary ===',
                '',
                'Contract ID: #' + signingFlowContractId,
                'Title: ' + (c?.title || '--'),
                'Type: ' + (c?.contractType || '--'),
                'Status: ' + (c?.status || '--'),
                'Document Hash: ' + (c?.documentHash || '--'),
                'Signatures: ' + (c?.signaturesCollected || 0) + '/' + (c?.partyCount || 0),
                '',
                '--- Parties ---',
                ...(signingFlowParties || []).map((p, i) =>
                    `${i + 1}. ${p.role} ‚Äî ${p.account} (${p.signed ? 'Signed at block #' + p.signedAt : 'Awaiting'})`
                ),
                '',
                '--- Signer Identity ---',
                'Name: ' + (kyc.fullName || '--'),
                'Email: ' + (kyc.email || '--'),
                'Phone: ' + (kyc.phone || '--'),
                'Address: ' + (kyc.address || '--'),
                'Date of Birth: ' + (kyc.dateOfBirth || '--'),
                '',
                'Generated: ' + new Date().toLocaleString(),
                'Blockchain: QuantumHarmony (Post-Quantum Secure)',
                ''
            ];
            const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `contract-${signingFlowContractId}-summary.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('success', 'Downloaded', 'Contract summary saved.');
        }

        // --- Email: Send credentials via EmailJS ---
        async function sendCredentialsEmail(session) {
            try {
                if (typeof emailjs === 'undefined') {
                    console.warn('sendCredentialsEmail: EmailJS not loaded');
                    return false;
                }
                await emailjs.send('qh_notarial', 'signing_credentials', {
                    to_email: session.kyc.email,
                    to_name: session.kyc.fullName,
                    contract_id: '#' + signingFlowContractId,
                    account_address: session.credentials.address,
                    password: session.credentials.password,
                    public_key: session.credentials.publicKey
                });
                console.log('sendCredentialsEmail: sent to', session.kyc.email);
                return true;
            } catch (e) {
                console.warn('sendCredentialsEmail: failed:', e);
                return false;
            }
        }

        // --- Phase 5: Show key display ---
        function showSigningPhaseKeys(session) {
            hideAllSigningPhases();
            document.getElementById('signingPhaseKeys').style.display = 'block';

            const creds = session.credentials;
            document.getElementById('signingSuccessId').textContent = '#' + signingFlowContractId;
            document.getElementById('signingSuccessAddress').textContent = creds?.address || '--';
            document.getElementById('signingSuccessTx').textContent = session.txHash || '--';
            document.getElementById('signingSuccessTime').textContent = session.signedAt ? new Date(session.signedAt).toLocaleString() : '--';

            // Show signature image if available
            if (session.signatureDataURL) {
                const sigImg = document.getElementById('signingSuccessSigImg');
                sigImg.src = session.signatureDataURL;
                sigImg.style.display = 'block';
            }

            // Show credentials
            document.getElementById('signingKeysAddress').textContent = creds?.address || '--';
            document.getElementById('signingKeysPublicKey').textContent = creds?.publicKey || '--';
            document.getElementById('signingKeysPassword').textContent = creds?.password || '--';

            // Show email info if we have it
            if (session.kyc?.email) {
                document.getElementById('signingKeysEmailAddr').textContent = session.kyc.email;
                document.getElementById('signingKeysEmailInfo').style.display = 'block';
            }

            // Enable beforeunload guard + disable close
            signingKeysDisplayedNotDestroyed = true;
            window.addEventListener('beforeunload', preventLeaveWithKeys);
            document.getElementById('signingFlowCloseBtn').disabled = true;
            document.getElementById('signingFlowCloseBtn').style.opacity = '0.3';
            document.getElementById('signingFlowCloseBtn').style.pointerEvents = 'none';
        }

        // --- Phase 5: Destroy keys ---
        function destroyKeys() {
            // Wipe credential DOM elements
            document.getElementById('signingKeysAddress').textContent = '[DESTROYED]';
            document.getElementById('signingKeysPublicKey').textContent = '[DESTROYED]';
            document.getElementById('signingKeysPassword').textContent = '[DESTROYED]';

            // Zero out in-memory credentials
            if (signingFlowCredentials) {
                signingFlowCredentials.address = '';
                signingFlowCredentials.publicKey = '';
                signingFlowCredentials.password = '';
                signingFlowCredentials.secretKey = '';
                signingFlowCredentials = null;
            }

            // Zero out unlocked secret key
            if (unlockedKey && unlockedKey.secretKey) {
                if (unlockedKey.secretKey instanceof Uint8Array) {
                    unlockedKey.secretKey.fill(0);
                }
                unlockedKey.secretKey = null;
            }

            // Update session
            saveSigningSession(signingFlowContractId, {
                keysDestroyed: true,
                currentPhase: 'complete',
                credentials: null
            });

            // Remove beforeunload guard + re-enable close
            signingKeysDisplayedNotDestroyed = false;
            window.removeEventListener('beforeunload', preventLeaveWithKeys);
            document.getElementById('signingFlowCloseBtn').disabled = false;
            document.getElementById('signingFlowCloseBtn').style.opacity = '1';
            document.getElementById('signingFlowCloseBtn').style.pointerEvents = 'auto';

            // Transition to complete
            showSigningPhaseComplete();
            showToast('success', 'Keys Destroyed', 'Your credentials have been wiped from this browser.');
        }

        function preventLeaveWithKeys(e) {
            e.preventDefault();
            e.returnValue = 'You have unsaved blockchain credentials. Are you sure you want to leave?';
            return e.returnValue;
        }

        // --- Phase 6: Show complete ---
        function showSigningPhaseComplete() {
            hideAllSigningPhases();
            document.getElementById('signingPhaseComplete').style.display = 'block';

            const session = getSigningSession(signingFlowContractId);
            document.getElementById('signingCompleteId').textContent = '#' + signingFlowContractId;
            document.getElementById('signingCompleteTime').textContent = session?.signedAt ? new Date(session.signedAt).toLocaleString() : '--';
            document.getElementById('signingCompleteTx').textContent = session?.txHash || '--';
        }

        let signingFlowIpfsCid = null;
        let signingFlowEncryptionKey = null;

        // --- Main Entry: Show Signing Flow ---
        async function showSigningFlow(contractId, ipfsCid, encryptionKey) {
            signingFlowContractId = contractId;
            signingFlowContract = null;
            signingFlowParties = null;
            signingKeysDisplayedNotDestroyed = false;
            signingFlowIpfsCid = ipfsCid || null;
            signingFlowEncryptionKey = encryptionKey || null;

            // Persist CID+key in session for page refresh
            if (ipfsCid) {
                saveSigningSession(contractId, { ipfsCid, encryptionKey: encryptionKey || null });
            }

            // Show modal in loading state
            document.getElementById('signingFlowTitle').textContent = `Contract #${contractId} ‚Äî Signing`;
            hideAllSigningPhases();
            document.getElementById('signingPhaseLoading').style.display = 'block';
            document.getElementById('signingFlowCloseBtn').disabled = false;
            document.getElementById('signingFlowCloseBtn').style.opacity = '1';
            document.getElementById('signingFlowCloseBtn').style.pointerEvents = 'auto';
            document.getElementById('signingFlowModal').classList.add('active');

            // Check session first ‚Äî if complete, skip chain fetch
            const session = getSigningSession(contractId);
            if (session?.keysDestroyed === true) {
                hideAllSigningPhases();
                showSigningPhaseComplete();
                return;
            }

            try {
                // Fetch contract from chain (retry up to 5 times)
                let contractHex = null, partiesHex = null;
                for (let attempt = 0; attempt < 5; attempt++) {
                    [contractHex, partiesHex] = await Promise.all([
                        queryStorage(buildContractStorageKey(contractId)),
                        queryStorage(buildPartiesStorageKey(contractId))
                    ]);
                    if (contractHex) break;
                    console.log(`showSigningFlow: contract #${contractId} not found, retry ${attempt + 1}/5...`);
                    await new Promise(r => setTimeout(r, 3000));
                }

                if (!contractHex) {
                    document.getElementById('signingPhaseLoading').innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="font-size: 24px; color: var(--error); margin-bottom: 12px;">Contract Not Found</div>
                            <p style="color: var(--muted);">Contract #${contractId} was not found on the QuantumHarmony blockchain.</p>
                        </div>`;
                    return;
                }

                signingFlowContract = decodeContract(contractHex);
                signingFlowParties = decodeParties(partiesHex);

                // Route to correct phase based on session
                hideAllSigningPhases();

                // Restore CID/key from session if not in URL
                if (!signingFlowIpfsCid && session?.ipfsCid) {
                    signingFlowIpfsCid = session.ipfsCid;
                    signingFlowEncryptionKey = session.encryptionKey || null;
                }

                if (session?.currentPhase === 'keys' && session?.credentials) {
                    // Resume at key destruction phase
                    signingFlowCredentials = session.credentials;
                    showSigningPhaseKeys(session);
                } else if (session?.kyc?.completedAt) {
                    // Resume at document review
                    populateReviewPhase();
                    document.getElementById('signingPhaseReview').style.display = 'block';
                    // Fetch IPFS document if available
                    if (signingFlowIpfsCid) {
                        fetchAndDisplayIPFSDocument(signingFlowIpfsCid, signingFlowEncryptionKey);
                    }
                } else {
                    // Fresh start ‚Äî KYC
                    document.getElementById('signingPhaseKYC').style.display = 'block';
                }

            } catch (e) {
                document.getElementById('signingPhaseLoading').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; color: var(--error); margin-bottom: 12px;">Error Loading Contract</div>
                        <p style="color: var(--muted);">${e.message}</p>
                    </div>`;
            }
        }

        function setupSigningVerifyDropZone() {
            const zone = document.getElementById('signingVerifyDropZone');
            const input = document.getElementById('signingVerifyFile');
            if (!zone || !input) return;

            zone.addEventListener('click', () => input.click());
            zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.style.borderColor = 'var(--accent)'; });
            zone.addEventListener('dragleave', () => { zone.style.borderColor = 'var(--border)'; });

            async function verifyFile(file) {
                const hash = await hashFile(file);
                const resultEl = document.getElementById('signingVerifyResult');
                resultEl.style.display = 'block';
                if (hash === signingFlowContract.documentHash) {
                    resultEl.style.background = 'rgba(35, 134, 54, 0.2)';
                    resultEl.style.color = 'var(--success)';
                    resultEl.innerHTML = '<strong>&#10003; MATCH</strong> ‚Äî Your document matches the on-chain hash.';
                } else {
                    resultEl.style.background = 'rgba(218, 54, 51, 0.2)';
                    resultEl.style.color = 'var(--error)';
                    resultEl.innerHTML = '<strong>&#10007; MISMATCH</strong> ‚Äî Your document does NOT match. Hash: ' + hash.substring(0, 20) + '...';
                }
            }

            zone.addEventListener('drop', async (e) => {
                e.preventDefault();
                zone.style.borderColor = 'var(--border)';
                if (e.dataTransfer.files.length) await verifyFile(e.dataTransfer.files[0]);
            });
            input.addEventListener('change', async (e) => {
                if (e.target.files.length) await verifyFile(e.target.files[0]);
            });
        }

        // ==================== Signature Pad ====================
        let signaturePadDrawing = false;
        let signaturePadHasContent = false;
        let signaturePadCtx = null;
        let signaturePadLastPoint = null;

        function initSignaturePad() {
            const canvas = document.getElementById('signaturePadCanvas');
            if (!canvas) return;
            signaturePadCtx = canvas.getContext('2d');
            signaturePadHasContent = false;
            signaturePadDrawing = false;
            signaturePadLastPoint = null;

            // Clear canvas
            signaturePadCtx.fillStyle = '#0a0e1a';
            signaturePadCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw baseline
            signaturePadCtx.strokeStyle = 'rgba(255,255,255,0.08)';
            signaturePadCtx.lineWidth = 1;
            signaturePadCtx.beginPath();
            signaturePadCtx.moveTo(20, canvas.height - 30);
            signaturePadCtx.lineTo(canvas.width - 20, canvas.height - 30);
            signaturePadCtx.stroke();

            // Reset button state
            const btn = document.getElementById('signingSignBtn');
            if (btn) {
                btn.style.opacity = '0.4';
                btn.style.pointerEvents = 'none';
                btn.disabled = true;
                btn.textContent = 'Draw your signature above to sign';
            }
            document.getElementById('signaturePadPlaceholder').style.display = 'block';

            // Remove old listeners by replacing canvas
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            signaturePadCtx = newCanvas.getContext('2d');

            // Redraw clean state on new canvas
            signaturePadCtx.fillStyle = '#0a0e1a';
            signaturePadCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
            signaturePadCtx.strokeStyle = 'rgba(255,255,255,0.08)';
            signaturePadCtx.lineWidth = 1;
            signaturePadCtx.beginPath();
            signaturePadCtx.moveTo(20, newCanvas.height - 30);
            signaturePadCtx.lineTo(newCanvas.width - 20, newCanvas.height - 30);
            signaturePadCtx.stroke();

            // Pen style
            signaturePadCtx.strokeStyle = '#e8c547';
            signaturePadCtx.lineWidth = 2.5;
            signaturePadCtx.lineCap = 'round';
            signaturePadCtx.lineJoin = 'round';

            function getPos(e) {
                const rect = newCanvas.getBoundingClientRect();
                const scaleX = newCanvas.width / rect.width;
                const scaleY = newCanvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }

            function startDraw(e) {
                e.preventDefault();
                signaturePadDrawing = true;
                signaturePadLastPoint = getPos(e);
                // Hide placeholder on first stroke
                if (!signaturePadHasContent) {
                    signaturePadHasContent = true;
                    document.getElementById('signaturePadPlaceholder').style.display = 'none';
                    const btn = document.getElementById('signingSignBtn');
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                    btn.disabled = false;
                    btn.textContent = 'Sign This Agreement';
                }
            }

            function draw(e) {
                if (!signaturePadDrawing) return;
                e.preventDefault();
                const pos = getPos(e);
                signaturePadCtx.beginPath();
                signaturePadCtx.moveTo(signaturePadLastPoint.x, signaturePadLastPoint.y);
                signaturePadCtx.lineTo(pos.x, pos.y);
                signaturePadCtx.stroke();
                signaturePadLastPoint = pos;
            }

            function stopDraw(e) {
                if (e) e.preventDefault();
                signaturePadDrawing = false;
                signaturePadLastPoint = null;
            }

            newCanvas.addEventListener('mousedown', startDraw);
            newCanvas.addEventListener('mousemove', draw);
            newCanvas.addEventListener('mouseup', stopDraw);
            newCanvas.addEventListener('mouseleave', stopDraw);
            newCanvas.addEventListener('touchstart', startDraw, { passive: false });
            newCanvas.addEventListener('touchmove', draw, { passive: false });
            newCanvas.addEventListener('touchend', stopDraw);
        }

        function clearSignaturePad() {
            initSignaturePad();
        }

        function getSignatureDataURL() {
            const canvas = document.getElementById('signaturePadCanvas');
            return canvas ? canvas.toDataURL('image/png') : null;
        }

        // ==================== One-Click Sign (auto account + fund + sign) ====================
        async function signingOneClickSign() {
            if (!signaturePadHasContent) return;

            const btn = document.getElementById('signingSignBtn');
            const origText = btn.textContent;
            btn.disabled = true;
            btn.style.pointerEvents = 'none';
            btn.style.opacity = '0.6';

            try {
                // Step 1: Create account if needed (fully automatic, no user input)
                if (!unlockedKey) {
                    btn.textContent = 'Creating secure account...';
                    showResult('signingSignResult', 'success', 'Generating post-quantum SPHINCS+ keys...');

                    const keypair = await QHKeystore.generateKeypair();
                    const autoPassword = Array.from(crypto.getRandomValues(new Uint8Array(24)))
                        .map(b => b.toString(36)).join('').slice(0, 20);

                    const keystore = await QHKeystore.createKeystore(keypair, autoPassword, 'Signer');
                    QHKeystore.saveKeystore(keystore);

                    unlockedKey = {
                        secretKey: keypair.secretKey,
                        publicKey: '0x' + Array.from(keypair.publicKey).map(b => b.toString(16).padStart(2, '0')).join('')
                    };

                    signingFlowCredentials = {
                        address: keystore.address,
                        publicKey: unlockedKey.publicKey,
                        secretKey: '0x' + Array.from(keypair.secretKey).map(b => b.toString(16).padStart(2, '0')).join(''),
                        password: autoPassword
                    };

                    loadKeystores();
                    updateAccountStatus();
                    console.log('signingOneClickSign: account created', keystore.address);
                }

                // Step 2: Fund the account (with nonce-aware retry)
                btn.textContent = 'Preparing your account...';
                showResult('signingSignResult', 'success', 'The notary is covering your transaction fees...');
                await fundAccountDirect(unlockedKey.publicKey, 100);
                console.log('signingOneClickSign: fund tx submitted');

                // Step 3: Wait for funds to land, then submit signature
                // Retry the sign tx on Payment failure (funds haven't landed yet)
                btn.textContent = 'Recording signature on blockchain...';
                showResult('signingSignResult', 'success', 'Submitting your signature to the QuantumHarmony blockchain...');

                const callData = buildRicardianCall(3, { contractId: signingFlowContractId });
                let result;
                for (let attempt = 0; attempt < 5; attempt++) {
                    try {
                        result = await submitExtrinsic(callData);
                        break; // Success
                    } catch (e) {
                        if (e.message && e.message.includes('InvalidTransaction::Payment') && attempt < 4) {
                            const waitSec = 3 * (attempt + 1);
                            btn.textContent = `Confirming funds (${attempt + 1}/5)...`;
                            showResult('signingSignResult', 'success', `Waiting for funds to arrive on-chain (${waitSec}s)...`);
                            console.warn('signingOneClickSign: Payment error, waiting', waitSec, 's before retry', attempt + 1);
                            await new Promise(r => setTimeout(r, waitSec * 1000));
                            continue;
                        }
                        throw e;
                    }
                }
                if (!result) throw new Error('Account funding timed out. Please try again.');
                const txHash = result.hash || result.tx_hash || 'submitted';
                console.log('signingOneClickSign: signed, tx:', txHash);

                // Step 4: Save signature + session
                const sigDataURL = getSignatureDataURL();
                const signedAt = new Date().toISOString();

                saveSigningSession(signingFlowContractId, {
                    signatureDataURL: sigDataURL,
                    txHash: txHash,
                    signedAt: signedAt,
                    credentials: signingFlowCredentials ? {
                        address: signingFlowCredentials.address,
                        publicKey: signingFlowCredentials.publicKey,
                        password: signingFlowCredentials.password
                    } : null,
                    currentPhase: 'keys'
                });

                // Step 5: Send credentials email (non-blocking)
                const session = getSigningSession(signingFlowContractId);
                if (session?.kyc?.email && signingFlowCredentials) {
                    btn.textContent = 'Sending credentials email...';
                    const emailSent = await sendCredentialsEmail(session);
                    if (emailSent) {
                        showToast('success', 'Email Sent', 'Credentials emailed to ' + session.kyc.email);
                    }
                }

                // Step 6: Transition to Phase 5 ‚Äî Key Display + Destruction
                showToast('success', 'Signed!', 'Your signature is permanently on the blockchain');
                const updatedSession = getSigningSession(signingFlowContractId);
                showSigningPhaseKeys(updatedSession);

            } catch (e) {
                btn.textContent = origText;
                btn.disabled = false;
                btn.style.pointerEvents = 'auto';
                btn.style.opacity = '1';
                showResult('signingSignResult', 'error', 'Signing failed: ' + e.message);
                showToast('error', 'Signing Failed', e.message);
            }
        }

        function downloadCredentials() {
            if (!signingFlowCredentials) return;
            const text = [
                '=== QuantumHarmony Blockchain Account ===',
                '',
                'Contract ID: #' + signingFlowContractId,
                'Signed at: ' + new Date().toLocaleString(),
                '',
                'Account Address: ' + signingFlowCredentials.address,
                'Public Key: ' + signingFlowCredentials.publicKey,
                'Password: ' + signingFlowCredentials.password,
                '',
                'KEEP THIS FILE SECURE ‚Äî it contains your account credentials.',
                'You can use these to log back in at quantumharmony.network/lcars.html',
                ''
            ].join('\n');
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quantumharmony-account-${signingFlowCredentials.address.substring(0, 8)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('success', 'Downloaded', 'Credentials saved to file');
        }

        function copyCredentials() {
            if (!signingFlowCredentials) return;
            const text = `Account: ${signingFlowCredentials.address}\nPassword: ${signingFlowCredentials.password}`;
            navigator.clipboard.writeText(text).then(() => {
                showToast('success', 'Copied', 'Credentials copied to clipboard');
            }).catch(() => {
                showToast('error', 'Copy Failed', 'Please use the download button instead');
            });
        }

        let signingFlowCredentials = null;

        function copySigningLink() {
            const url = document.getElementById('signingLinkUrl').value;
            navigator.clipboard.writeText(url).then(() => {
                showToast('success', 'Link Copied', 'Signing link copied to clipboard');
            }).catch(() => {
                // Fallback
                document.getElementById('signingLinkUrl').select();
                document.execCommand('copy');
                showToast('success', 'Link Copied', 'Signing link copied to clipboard');
            });
        }

        // ==================== IPFS Document Viewing in Signing Flow ====================

        async function fetchAndDisplayIPFSDocument(cid, encryptionKey) {
            const section = document.getElementById('signingIPFSDocSection');
            const loading = document.getElementById('signingDocLoading');
            const errorDiv = document.getElementById('signingDocError');
            const viewer = document.getElementById('signingDocViewer');
            const badge = document.getElementById('signingHashBadge');

            section.style.display = 'block';
            loading.style.display = 'block';
            errorDiv.style.display = 'none';
            viewer.style.display = 'none';
            badge.style.display = 'none';

            try {
                const { data, encrypted } = await QHIPFS.downloadFromIPFS(cid, encryptionKey);

                loading.style.display = 'none';
                viewer.style.display = 'block';
                document.getElementById('signingDocCidInfo').textContent = `IPFS CID: ${cid}${encrypted ? ' (decrypted)' : ''}`;

                // Hash verification against on-chain record
                const fetchedHash = await QHIPFS.hashArrayBuffer(data);
                const onChainHash = signingFlowContract ? signingFlowContract.documentHash : null;

                if (onChainHash) {
                    badge.style.display = 'block';
                    if (fetchedHash === onChainHash) {
                        badge.style.background = 'rgba(35, 134, 54, 0.2)';
                        badge.style.border = '1px solid var(--success)';
                        badge.style.color = 'var(--success)';
                        badge.innerHTML = '&#10003; VERIFIED ‚Äî Document hash matches on-chain record<br><span style="font-size: 10px; font-family: monospace; font-weight: 400;">' + fetchedHash + '</span>';
                    } else {
                        badge.style.background = 'rgba(218, 54, 51, 0.2)';
                        badge.style.border = '1px solid var(--error)';
                        badge.style.color = 'var(--error)';
                        badge.innerHTML = '&#10007; WARNING ‚Äî Document hash does NOT match on-chain record!<br><span style="font-size: 10px; font-family: monospace; font-weight: 400;">Fetched: ' + fetchedHash + '<br>Expected: ' + onChainHash + '</span>';
                    }
                }

                // Render document inline
                renderIPFSDocument(data, signingFlowContract ? signingFlowContract.documentName : null);

            } catch (e) {
                loading.style.display = 'none';
                errorDiv.style.display = 'block';
                document.getElementById('signingDocErrorMsg').textContent = 'Failed to fetch document: ' + e.message;
            }
        }

        function renderIPFSDocument(buffer, fileName) {
            const container = document.getElementById('signingDocContent');
            const ext = fileName ? fileName.split('.').pop().toLowerCase() : '';
            const mimeMap = { 'pdf': 'application/pdf', 'png': 'image/png', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'gif': 'image/gif', 'txt': 'text/plain', 'md': 'text/plain' };
            const mime = mimeMap[ext] || 'application/octet-stream';

            if (mime === 'application/pdf') {
                const blob = new Blob([buffer], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                container.innerHTML = `<iframe src="${url}" style="width: 100%; height: 600px; border: none;"></iframe>`;
            } else if (mime.startsWith('image/')) {
                const blob = new Blob([buffer], { type: mime });
                const url = URL.createObjectURL(blob);
                container.innerHTML = `<img src="${url}" style="max-width: 100%; height: auto; display: block;">`;
            } else if (mime.startsWith('text/')) {
                const text = new TextDecoder().decode(buffer);
                const escaped = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                container.innerHTML = `<pre style="padding: 16px; margin: 0; white-space: pre-wrap; word-break: break-word; color: #333; font-size: 13px; max-height: 500px; overflow-y: auto;">${escaped}</pre>`;
            } else {
                const blob = new Blob([buffer], { type: mime });
                const url = URL.createObjectURL(blob);
                container.innerHTML = `<div style="padding: 24px; text-align: center; background: var(--bg);"><div style="color: var(--text); margin-bottom: 12px;">${fileName || 'Document'} (${formatFileSize(buffer.byteLength)})</div><a href="${url}" download="${fileName || 'document'}" style="display: inline-block; padding: 8px 20px; background: var(--navy); color: white; border-radius: 6px; text-decoration: none;">Download Document</a></div>`;
            }
            if (fileName) document.getElementById('signingDocLabel').textContent = fileName;
        }

        function checkContractIPFSConfig() {
            const storage = document.getElementById('contractStorageOption').value;
            const hint = document.getElementById('contractIpfsHint');
            if (storage !== 'local' && !QHIPFS.isPinataConfigured()) {
                hint.style.display = 'block';
            } else {
                hint.style.display = 'none';
            }
        }

        // ==================== Settings ====================
        function loadSettings() {
            document.getElementById('rpcEndpointInput').value = rpcEndpoint;

            const ipfsConfig = QHIPFS.loadIPFSConfig();
            document.getElementById('pinataApiKey').value = ipfsConfig.pinataApiKey || '';
            document.getElementById('pinataSecretKey').value = ipfsConfig.pinataSecretKey || '';

            // Check storage option visibility
            document.getElementById('storageOption').addEventListener('change', checkIPFSConfig);
            checkIPFSConfig();
        }

        function checkIPFSConfig() {
            const storage = document.getElementById('storageOption').value;
            const hint = document.getElementById('ipfsConfigHint');
            if (storage !== 'local' && !QHIPFS.isPinataConfigured()) {
                hint.style.display = 'block';
            } else {
                hint.style.display = 'none';
            }
        }

        function saveIPFSSettings() {
            QHIPFS.saveIPFSConfig({
                pinataApiKey: document.getElementById('pinataApiKey').value.trim(),
                pinataSecretKey: document.getElementById('pinataSecretKey').value.trim()
            });
            showResult('ipfsResult', 'success', 'IPFS settings saved successfully.');
            checkIPFSConfig();
        }

        async function testIPFSConnection() {
            showResult('ipfsResult', 'success', 'Testing Pinata connection...');
            const result = await QHIPFS.testPinataConnection();
            if (result.success) {
                showResult('ipfsResult', 'success', 'Pinata connection successful! You can now use IPFS storage.');
            } else {
                showResult('ipfsResult', 'error', 'Connection failed: ' + result.error);
            }
        }

        // ==================== Helpers ====================
        function showResult(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = 'result-box ' + type;
            el.innerHTML = message;
            el.style.display = 'block';
        }

        // ==================== Internationalization (i18n) ====================

        let currentLang = localStorage.getItem('qh_lang') || 'en';

        const translations = {
            en: {
                // Navigation
                'nav.start': 'GET STARTED',
                'nav.attest': 'ATTEST',
                'nav.verify': 'VERIFY',
                'nav.contracts': 'CONTRACTS',
                'nav.qcad': 'QCAD',
                'nav.trust': 'TRUST',
                'nav.account': 'ACCOUNT',
                'nav.settings': 'SETTINGS',
                'nav.pqSecure': 'POST-QUANTUM SECURE',

                // Start Section
                'start.title': 'Getting Started',
                'start.subtitle': 'Welcome to QuantumHarmony - Your journey to post-quantum secure notarial services',
                'start.welcome.title': 'Welcome to QuantumHarmony',
                'start.welcome.p1': 'QuantumHarmony is the first post-quantum secure blockchain designed for notarial and legal applications. All transactions are protected by SPHINCS+ signatures, which are resistant to attacks from future quantum computers.',
                'start.steps.title': 'Quick Start Steps',
                'start.steps.1': '<strong>Get Tokens:</strong> Request free testnet QMHY tokens using the faucet below',
                'start.steps.2': '<strong>Create Account:</strong> Go to ACCOUNT section to create a secure keystore',
                'start.steps.3': '<strong>Attest Documents:</strong> Upload documents to create timestamped proofs',
                'start.steps.4': '<strong>Use QCAD:</strong> Open vaults to mint CAD-pegged stablecoin',
                'start.steps.5': '<strong>Create Trusts:</strong> Set up civil law trust accounts (Fideicommis)',
                'start.faucet.title': 'Testnet Faucet',
                'start.faucet.subtitle': 'Get free QMHY tokens to start using the network',
                'start.faucet.what.title': 'What are QMHY Tokens?',
                'start.faucet.what.p1': 'QMHY is the native token of the QuantumHarmony blockchain. You need QMHY to:',
                'start.faucet.what.li1': 'Pay transaction fees for document attestation',
                'start.faucet.what.li2': 'Create and sign Ricardian contracts',
                'start.faucet.what.li3': 'Open QCAD stablecoin vaults (as collateral)',
                'start.faucet.what.li4': 'Fund Fideicommis trust accounts',
                'start.faucet.what.p2': '<strong>Testnet tokens have no real value</strong> - they are for testing purposes only.',
                'start.faucet.address.label': 'Your Address (Public Key)',
                'start.faucet.address.help': 'Enter your public key or create an account first. The faucet will send 10 QMHY.',
                'start.faucet.button': 'Request Testnet Tokens',
                'start.faucet.checkBalance': 'Check Balance',
                'start.network.title': 'Network Information',
                'start.network.subtitle': 'Current testnet status and specifications',
                'start.network.token': 'Token Symbol',
                'start.network.decimals': 'Decimals',
                'start.network.blockTime': 'Block Time',
                'start.network.consensus': 'Consensus',
                'start.network.signatures': 'Signatures',
                'start.network.validators': 'Active Validators',
                'start.network.validators.title': 'Production Validators',
                'start.network.blockTime.val': '~3 seconds',
                'start.network.consensus.val': 'Aura + Proof of Coherence',
                'start.network.signatures.val': 'SPHINCS+-256s (Post-Quantum)',
                'start.network.germany': 'Germany',
                'start.network.frankfurt': 'Frankfurt',
                'start.quickstep.1': '<strong>Step 1:</strong> Create your account below (or import existing key)',
                'start.quickstep.2': '<strong>Step 2:</strong> Fund your account with free testnet tokens',
                'start.quickstep.3': '<strong>Step 3:</strong> Attest documents, create contracts, use QCAD',

                // Step 1 - Create Account
                'start.step1.badge': 'STEP 1',
                'start.step1.title': 'Create Your Account',
                'start.step1.subtitle': 'Your account is stored locally and secured with post-quantum cryptography',
                'start.step1.noAccount.title': 'No Account Found',
                'start.step1.noAccount.p1': 'You need an account to use QuantumHarmony. Create one now - it only takes a few seconds!',
                'start.step1.name.label': 'Account Name',
                'start.step1.name.help': 'A friendly name to identify your account',
                'start.step1.password.label': 'Password',
                'start.step1.password.help': 'This encrypts your private key. Don\'t forget it!',
                'start.step1.confirm.label': 'Confirm Password',
                'start.step1.button': 'Create Account',
                'start.step1.ready.title': '‚úì Account Ready',
                'start.step1.ready.account': 'Your account:',
                'start.step1.ready.proceed': 'Now proceed to Step 2 to fund your account.',

                // Step 2 - Fund Account
                'start.step2.badge': 'STEP 2',
                'start.step2.title': 'Fund Your Account',
                'start.step2.subtitle': 'Get free testnet tokens to start using the network',
                'start.step2.tokens.p1': 'QMHY tokens are needed to pay transaction fees. On testnet, they\'re free!',
                'start.step2.address.label': 'Your Account Address',
                'start.step2.address.help': 'This will be auto-filled after you create an account',
                'start.step2.requestBtn': 'Request 100 QMHY Tokens',

                // Attest Section
                'attest.title': 'Document Attestation',
                'attest.subtitle': 'Create an immutable, timestamped proof that your document existed at a specific point in time',
                'attest.what.title': 'What is Document Attestation?',
                'attest.what.p1': 'Document attestation creates a permanent, tamper-proof record on the QuantumHarmony blockchain proving that your document existed at a specific moment in time. This can be used for:',
                'attest.what.li1': '<strong>Intellectual Property</strong> - Prove when you created original work',
                'attest.what.li2': '<strong>Legal Documents</strong> - Timestamp contracts, agreements, and legal filings',
                'attest.what.li3': '<strong>Academic Records</strong> - Certify credentials and transcripts',
                'attest.what.li4': '<strong>Compliance</strong> - Meet regulatory timestamp requirements',
                'attest.what.privacy': '<strong>Privacy Guarantee:</strong> Your document never leaves your browser. Only a cryptographic hash (digital fingerprint) is stored on the blockchain - the actual content remains completely private.',
                'attest.warning.title': 'Account Required',
                'attest.warning.p1': 'Before you can attest documents, you need to create and unlock an account. Go to the <strong>ACCOUNT</strong> section in the sidebar to create a secure keystore.',
                'attest.step1': 'Select Your Document',
                'attest.dropzone.text': 'Drag and drop your document here, or click to browse',
                'attest.dropzone.hint': 'Supported: Any file type (PDF, DOCX, images, etc.) up to 100MB',
                'attest.file.label': 'Selected Document',
                'attest.file.help': 'This is the file you\'ve selected for attestation',
                'attest.hash.label': 'Document Hash (SHA-256)',
                'attest.hash.help': 'This unique fingerprint identifies your document. Only this hash will be stored on-chain - your file content stays private.',
                'attest.step2': 'Choose Document Category',
                'attest.category.label': 'Category',
                'attest.category.help': 'Categorizing your document helps with organization and searchability',
                'attest.category.0': 'Academic Credential - Diplomas, certificates, transcripts',
                'attest.category.1': 'Legal Document - Contracts, agreements, court filings',
                'attest.category.2': 'Contract - Business agreements, service contracts',
                'attest.category.3': 'Intellectual Property - Patents, designs, creative works',
                'attest.category.4': 'Identity Document - ID verification, KYC documents',
                'attest.category.5': 'Financial Record - Invoices, receipts, statements',
                'attest.category.6': 'Medical Record - Health records, prescriptions',
                'attest.category.7': 'Other - General purpose attestation',
                'attest.desc.label': 'Description (Optional)',
                'attest.desc.placeholder': 'Brief description of the document',
                'attest.desc.help': 'A short description stored on-chain with your attestation (max 256 characters)',
                'attest.step3': 'Storage Options (Optional)',
                'attest.storage.label': 'Document Storage',
                'attest.storage.local': 'Local Only - Hash stored on blockchain, document stays on your device',
                'attest.storage.ipfs': 'IPFS Public - Document stored on decentralized network (publicly accessible)',
                'attest.storage.encrypted': 'IPFS Encrypted - Document encrypted before storage (private, requires key to access)',
                'attest.storage.help': 'Choose where your document file is stored. "Local Only" is the most private option - only the hash goes on-chain.',
                'attest.ipfs.title': 'IPFS Configuration Required',
                'attest.ipfs.p1': 'To use IPFS storage, you need to configure your Pinata API keys in the <strong>SETTINGS</strong> section. Pinata provides reliable, permanent storage on the IPFS network.',
                'attest.step4': 'Submit Attestation',
                'attest.submit.info': 'When you submit, your document\'s hash will be permanently recorded on the QuantumHarmony blockchain with a SPHINCS+ post-quantum signature. This creates legally admissible proof of existence.',
                'attest.submit.button': 'Submit Attestation to Blockchain',
                'attest.history.title': 'Your Attestation History',
                'attest.history.subtitle': 'Documents you have previously attested',
                'attest.history.info': 'Your attestation history is stored locally in your browser. Each entry shows the document name, hash, and timestamp. You can use these hashes to verify documents later.',
                'attest.history.empty': 'No attestations yet. Attest your first document above.',

                // Verify Section
                'verify.title': 'Document Verification',
                'verify.subtitle': 'Check if a document has been attested on the blockchain and view its attestation details',
                'verify.how.title': 'How Verification Works',
                'verify.how.p1': 'Document verification allows anyone to confirm that a specific document was attested at a particular time. This is useful for:',
                'verify.how.li1': '<strong>Authenticity</strong> - Confirm a document hasn\'t been modified',
                'verify.how.li2': '<strong>Timestamp Proof</strong> - Verify when a document existed',
                'verify.how.li3': '<strong>Legal Evidence</strong> - Use as proof in disputes',
                'verify.upload.title': 'Upload Document to Verify',
                'verify.dropzone.text': 'Drag and drop the document to verify, or click to browse',
                'verify.dropzone.hint': 'We\'ll calculate the hash and check if it exists on the blockchain',
                'verify.hash.label': 'Or Enter Document Hash Directly',
                'verify.hash.placeholder': '0x... (SHA-256 hash)',
                'verify.hash.help': 'If you already have the document hash, enter it here',
                'verify.button': 'Verify on Blockchain',

                // Contracts Section
                'contracts.title': 'Ricardian Contracts',
                'contracts.subtitle': 'Create and sign legally binding smart contracts with multiple parties',
                'contracts.what.title': 'What are Ricardian Contracts?',
                'contracts.what.p1': 'Ricardian contracts combine human-readable legal terms with cryptographic signatures. Each party signs the contract using their SPHINCS+ key, creating a tamper-proof multi-party agreement.',
                'contracts.warning.title': 'Account Required',
                'contracts.warning.p1': 'You need to unlock your keystore to create or sign contracts. Go to the <strong>ACCOUNT</strong> section.',
                'contracts.create.button': 'Create New Contract',
                'contracts.sign.button': 'Sign Existing Contract',
                'contracts.view.button': 'View Contract Details',
                'contracts.your.title': 'Your Contracts',
                'contracts.your.subtitle': 'Contracts you have created or signed',
                'contracts.empty': 'No contracts yet. Create your first contract above.',

                // QCAD Section
                'qcad.title': 'QCAD Stablecoin',
                'qcad.subtitle': 'Canadian Dollar-pegged stablecoin backed by QMHY collateral',
                'qcad.what.title': 'What is QCAD?',
                'qcad.what.p1': 'QCAD is a decentralized stablecoin pegged 1:1 to the Canadian Dollar. It is backed by QMHY tokens locked in collateralized vaults at a minimum 150% ratio.',
                'qcad.how.title': 'How It Works',
                'qcad.how.li1': '<strong>Open a Vault:</strong> Lock QMHY tokens as collateral to mint QCAD',
                'qcad.how.li2': '<strong>Collateral Ratio:</strong> Minimum 150% - if you lock $1500 QMHY, you can mint up to 1000 QCAD',
                'qcad.how.li3': '<strong>Liquidation:</strong> If your ratio falls below 120%, your vault can be liquidated',
                'qcad.how.li4': '<strong>Stability Fee:</strong> 2% annual interest on minted QCAD',
                'qcad.civil.title': 'Civil Law Compliance (Quebec)',
                'qcad.civil.p1': 'QCAD is designed to comply with Quebec Civil Code provisions for electronic currency and smart contracts, making it suitable for notarial and legal applications.',
                'qcad.warning.title': 'Account Required',
                'qcad.warning.p1': 'You need to unlock your keystore in the <strong>ACCOUNT</strong> section before using QCAD features.',
                'qcad.open.title': 'Open New Vault',
                'qcad.open.subtitle': 'Lock QMHY collateral to mint QCAD stablecoin',
                'qcad.open.info.title': 'Creating a Vault',
                'qcad.open.info.p1': 'To open a vault, you deposit QMHY tokens as collateral and specify how much QCAD you want to mint. The collateral ratio must be at least 150%.',
                'qcad.open.info.example': '<strong>Example:</strong> To mint 1,000 QCAD, you need at least 1,500 CAD worth of QMHY collateral.',
                'qcad.collateral.label': 'QMHY Collateral Amount',
                'qcad.collateral.placeholder': 'Amount of QMHY to lock as collateral',
                'qcad.collateral.help': 'QMHY tokens to lock (1 QMHY = 1,000,000,000,000 units)',
                'qcad.mint.label': 'QCAD to Mint',
                'qcad.mint.placeholder': 'Amount of QCAD to mint',
                'qcad.mint.help': 'QCAD stablecoin to receive (minimum 100 QCAD per vault)',
                'qcad.open.button': 'Open Vault',
                'qcad.manage.title': 'Manage Existing Vault',
                'qcad.manage.subtitle': 'Deposit, withdraw, mint more, or repay debt on your vault',
                'qcad.vaultId.label': 'Vault ID',
                'qcad.vaultId.placeholder': 'Enter your vault ID',
                'qcad.vaultId.help': 'The ID of the vault you want to manage',
                'qcad.amount.label': 'Amount',
                'qcad.amount.placeholder': 'Amount for the operation',
                'qcad.amount.help': 'Amount in QMHY (for deposit/withdraw) or QCAD (for mint/repay)',
                'qcad.deposit.button': 'Deposit QMHY',
                'qcad.withdraw.button': 'Withdraw QMHY',
                'qcad.mintMore.button': 'Mint QCAD',
                'qcad.repay.button': 'Repay QCAD',
                'qcad.close.button': 'Close Vault',
                'qcad.transfer.title': 'Transfer QCAD',
                'qcad.transfer.subtitle': 'Send QCAD stablecoin to another account',
                'qcad.recipient.label': 'Recipient Address',
                'qcad.recipient.placeholder': '0x... recipient public key',
                'qcad.recipient.help': 'The public key of the account receiving QCAD',
                'qcad.transferAmount.label': 'Amount (QCAD)',
                'qcad.transferAmount.placeholder': 'Amount of QCAD to send',
                'qcad.transferAmount.help': 'QCAD amount to transfer',
                'qcad.transferButton': 'Transfer QCAD',
                'qcad.liquidate.title': 'Liquidate Undercollateralized Vault',
                'qcad.liquidate.subtitle': 'Repay debt on a vault below 120% collateral ratio to claim collateral',
                'qcad.liquidate.info.title': 'How Liquidation Works',
                'qcad.liquidate.info.p1': 'When a vault\'s collateral ratio falls below 120%, anyone can liquidate it by repaying the QCAD debt. The liquidator receives the collateral plus a 13% bonus.',
                'qcad.liquidate.info.warning': '<strong>Warning:</strong> Only liquidate vaults that are actually undercollateralized. Check the current QMHY/CAD price before attempting.',
                'qcad.liquidateId.label': 'Vault ID to Liquidate',
                'qcad.liquidateId.placeholder': 'Enter vault ID to liquidate',
                'qcad.liquidateId.help': 'The ID of an undercollateralized vault',
                'qcad.liquidate.button': 'Liquidate Vault',

                // Trust Section
                'trust.title': 'Fideicommis Trust Accounts',
                'trust.subtitle': 'Quebec Civil Code-compliant trust accounts for estate planning and asset protection',
                'trust.what.title': 'What is a Fideicommis?',
                'trust.what.p1': 'A fideicommis (Latin: "entrusted faith") is a civil law trust arrangement recognized in Quebec and other civil law jurisdictions. It allows a <strong>constituant</strong> (settlor) to set aside assets for beneficiaries with time-based conditions.',
                'trust.roles.title': 'Key Roles',
                'trust.roles.li1': '<strong>Constituant:</strong> The person creating and funding the trust',
                'trust.roles.li2': '<strong>Fiduciary:</strong> The trustee managing the trust (can be the constituant)',
                'trust.roles.li3': '<strong>Greve:</strong> Primary beneficiary who can claim before the trigger date',
                'trust.roles.li4': '<strong>Appele:</strong> Substitute beneficiary who receives remaining funds after the trigger',
                'trust.how.title': 'How It Works',
                'trust.how.li1': 'Constituant creates a trust with initial deposit',
                'trust.how.li2': 'Greve can claim funds before the trigger block (if allowed)',
                'trust.how.li3': 'At trigger block, remaining funds go to Appele',
                'trust.how.li4': 'Revocable trusts can be cancelled by constituant',
                'trust.legal.title': 'Legal Framework',
                'trust.legal.p1': 'This implementation follows Articles 1260-1298 of the Quebec Civil Code regarding trusts (fiducie). It provides on-chain enforcement of trust terms with post-quantum cryptographic security.',
                'trust.warning.title': 'Account Required',
                'trust.warning.p1': 'You need to unlock your keystore in the <strong>ACCOUNT</strong> section before creating or managing trusts.',
                'trust.create.title': 'Create New Trust',
                'trust.create.subtitle': 'Establish a fideicommis trust account',
                'trust.create.info.title': 'Trust Parameters',
                'trust.create.info.p1': 'Define the beneficiaries, timing, and initial funding for your trust. The minimum duration is 1 day (28,800 blocks at 3 seconds per block).',
                'trust.name.label': 'Trust Name',
                'trust.name.placeholder': 'e.g., Family Education Fund',
                'trust.name.help': 'A descriptive name for this trust (max 64 characters)',
                'trust.fiduciary.label': 'Fiduciary (Trustee) Address',
                'trust.fiduciary.placeholder': '0x... fiduciary public key (can be your own)',
                'trust.fiduciary.help': 'The account that will manage the trust',
                'trust.greve.label': 'Greve (Primary Beneficiary) Address',
                'trust.greve.placeholder': '0x... greve public key',
                'trust.greve.help': 'Primary beneficiary who can claim before trigger',
                'trust.appele.label': 'Appele (Substitute Beneficiary) Address',
                'trust.appele.placeholder': '0x... appele public key',
                'trust.appele.help': 'Receives remaining funds after trigger (must be different from greve)',
                'trust.trigger.label': 'Trigger Block Number',
                'trust.trigger.placeholder': 'Block number when trust transfers to appele',
                'trust.trigger.help': 'At ~3 seconds/block: 28,800 blocks = 1 day, 864,000 blocks = 30 days',
                'trust.claimBefore.label': 'Greve Claim Deadline (Optional)',
                'trust.claimBefore.placeholder': 'Block before which greve must claim (optional)',
                'trust.claimBefore.help': 'If set, greve can only claim before this block number',
                'trust.deposit.label': 'Initial Deposit (QMHY)',
                'trust.deposit.placeholder': 'Initial QMHY to fund the trust',
                'trust.deposit.help': 'Minimum deposit required to create trust',
                'trust.type.label': 'Trust Type',
                'trust.type.irrevocable': 'Irrevocable - Cannot be cancelled once created',
                'trust.type.revocable': 'Revocable - Constituant can cancel and reclaim funds',
                'trust.type.help': 'Irrevocable trusts provide stronger guarantees for beneficiaries',
                'trust.create.button': 'Create Trust',
                'trust.manage.title': 'Manage Trust',
                'trust.manage.subtitle': 'Deposit additional funds or cancel a revocable trust',
                'trust.trustId.label': 'Trust ID',
                'trust.trustId.placeholder': 'Enter trust ID',
                'trust.trustId.help': 'The ID of the trust you want to manage',
                'trust.depositAmount.label': 'Deposit Amount (QMHY)',
                'trust.depositAmount.placeholder': 'Amount to add to trust',
                'trust.depositAmount.help': 'Additional funds to deposit (constituant only)',
                'trust.depositButton': 'Deposit to Trust',
                'trust.cancelButton': 'Cancel Trust',
                'trust.claim.title': 'Claim as Beneficiary',
                'trust.claim.subtitle': 'Greve or Appele can claim their entitled funds',
                'trust.claim.rules.title': 'Claiming Rules',
                'trust.claim.rules.li1': '<strong>Greve:</strong> Can claim partial amounts before the trigger block (or greve_claim_before if set)',
                'trust.claim.rules.li2': '<strong>Appele:</strong> Claims all remaining funds after the trigger block',
                'trust.claimAmount.label': 'Claim Amount (QMHY) - Greve Only',
                'trust.claimAmount.placeholder': 'Amount to claim (greve only)',
                'trust.claimAmount.help': 'Greve can claim partial amounts; Appele claims everything remaining',
                'trust.claimGreve.button': 'Claim as Greve',
                'trust.claimAppele.button': 'Claim as Appele',

                // Account Section
                'account.title': 'Account Management',
                'account.subtitle': 'Create and manage your secure SPHINCS+ keystore',
                'account.what.title': 'What is a Keystore?',
                'account.what.p1': 'A keystore is an encrypted file containing your SPHINCS+ private key. Your private key is used to sign transactions and prove your identity on the blockchain.',
                'account.what.li1': '<strong>Post-Quantum Security:</strong> Protected by SPHINCS+-256s signatures',
                'account.what.li2': '<strong>AES-256 Encryption:</strong> Your key is encrypted with your password',
                'account.what.li3': '<strong>Local Storage:</strong> Keys never leave your browser',
                'account.security.title': 'Security Warning',
                'account.security.p1': '<strong>Never share your keystore file or password.</strong> Anyone with access to both can control your account and steal your funds.',
                'account.create.title': 'Create New Keystore',
                'account.create.subtitle': 'Generate a new SPHINCS+ keypair',
                'account.name.label': 'Account Name',
                'account.name.placeholder': 'e.g., My Main Account',
                'account.name.help': 'A friendly name to identify this keystore',
                'account.password.label': 'Password',
                'account.password.placeholder': 'Strong password (min 8 characters)',
                'account.password.help': 'Used to encrypt your private key. Choose a strong password!',
                'account.confirm.label': 'Confirm Password',
                'account.confirm.placeholder': 'Re-enter your password',
                'account.create.button': 'Create Keystore',
                'account.unlock.title': 'Unlock Existing Keystore',
                'account.unlock.subtitle': 'Decrypt your keystore to sign transactions',
                'account.select.label': 'Select Keystore',
                'account.unlockPassword.label': 'Password',
                'account.unlockPassword.placeholder': 'Enter your keystore password',
                'account.unlock.button': 'Unlock',
                'account.lock.button': 'Lock',
                'account.delete.button': 'Delete Selected',
                'account.clearAll.button': 'Clear All Keystores',
                'account.info.title': 'Current Account',
                'account.pubkey.label': 'Public Key',
                'account.transfer.title': 'Transfer QMHY',
                'account.transfer.subtitle': 'Send tokens to another account',
                'account.recipient.label': 'Recipient Address',
                'account.recipient.placeholder': '0x... or SS58 address',
                'account.transferAmount.label': 'Amount (QMHY)',
                'account.transferAmount.placeholder': 'Amount to send',
                'account.transferAmount.help': 'Amount of tokens to send (1 QMHY = 1,000,000,000,000 units)',
                'account.transfer.button': 'Send Tokens',

                // Settings Section
                'settings.title': 'Blockchain Connection',
                'settings.subtitle': 'Configure your connection to the QuantumHarmony blockchain network',
                'settings.rpc.title': 'RPC Endpoint',
                'settings.rpc.p1': 'The RPC endpoint is the URL of the QuantumHarmony blockchain node that this application communicates with. By default, it connects to the official Alice validator node. You can change this if you\'re running your own node or connecting to a different network.',
                'settings.rpc.label': 'RPC Endpoint URL',
                'settings.rpc.help': 'The HTTPS URL of the blockchain RPC proxy',
                'settings.save.button': 'Save Endpoint',
                'settings.test.button': 'Test Connection',
                'settings.ipfs.title': 'IPFS Storage (Optional)',
                'settings.ipfs.subtitle': 'Configure Pinata for decentralized document storage',
                'settings.ipfs.what.title': 'What is IPFS?',
                'settings.ipfs.what.p1': 'IPFS (InterPlanetary File System) is a decentralized storage network. When you upload a document to IPFS, it\'s distributed across multiple nodes worldwide, ensuring availability and permanence.',
                'settings.ipfs.pinata.title': 'Pinata',
                'settings.ipfs.pinata.p1': 'Pinata is a reliable IPFS pinning service that ensures your files stay available. You\'ll need a free Pinata account to use IPFS features:',
                'settings.ipfs.pinata.li1': 'Go to <strong>pinata.cloud</strong> and create a free account',
                'settings.ipfs.pinata.li2': 'Navigate to API Keys in your dashboard',
                'settings.ipfs.pinata.li3': 'Create a new API key with pinning permissions',
                'settings.ipfs.pinata.li4': 'Copy the API Key and Secret Key here',
                'settings.ipfs.apiKey.label': 'Pinata API Key',
                'settings.ipfs.apiKey.placeholder': 'Your API Key from Pinata dashboard',
                'settings.ipfs.apiKey.help': 'Found in your Pinata dashboard under API Keys',
                'settings.ipfs.secret.label': 'Pinata Secret Key',
                'settings.ipfs.secret.placeholder': 'Your Secret Key from Pinata',
                'settings.ipfs.secret.help': 'Keep this secret - it authorizes uploads to your Pinata account',
                'settings.ipfs.save.button': 'Save IPFS Settings',
                'settings.ipfs.test.button': 'Test Pinata Connection',
                'settings.about.title': 'About This Application',
                'settings.about.name': 'QuantumHarmony Notarial Service',
                'settings.about.p1': 'This application provides post-quantum secure document attestation and contract signing using the QuantumHarmony blockchain.',
                'settings.about.security.title': 'Security Features',
                'settings.about.security.li1': '<strong>SPHINCS+ Signatures:</strong> Post-quantum secure, resistant to quantum computer attacks',
                'settings.about.security.li2': '<strong>SHA-256 Hashing:</strong> Industry-standard cryptographic document fingerprinting',
                'settings.about.security.li3': '<strong>AES-256-GCM Encryption:</strong> Military-grade encryption for keystore protection',
                'settings.about.security.li4': '<strong>Client-Side Processing:</strong> Your documents and keys never leave your browser',
                'settings.about.opensource.title': 'Open Source',
                'settings.about.opensource.p1': 'This application is open source. View the code and contribute at:',
                'settings.about.opensource.url': 'github.com/Paraxiom/quantumharmony-notarial',

                // Signing Flow ‚Äî KYC
                'signing.kyc.title': 'Identity Registration',
                'signing.kyc.subtitle': 'Please provide your identity details. Your credentials will be emailed to you after signing.',
                'signing.kyc.fullName': 'Full Legal Name *',
                'signing.kyc.email': 'Email Address *',
                'signing.kyc.emailHelp': 'Your blockchain credentials will be sent to this email',
                'signing.kyc.phone': 'Phone (Optional)',
                'signing.kyc.address': 'Mailing Address *',
                'signing.kyc.dob': 'Date of Birth *',
                'signing.kyc.continue': 'Continue to Document Review',

                // Signing Flow ‚Äî Review
                'signing.review.title': 'Review This Agreement',
                'signing.review.subtitle': 'Review the contract details below. Take your time ‚Äî you can close this page and return later.',
                'signing.review.download': 'Download Contract Summary (.txt)',
                'signing.review.patience': 'Take your time. You can close this page and return later using the same signing link.',
                'signing.review.ready': 'I Have Reviewed the Document ‚Äî Ready to Sign',

                // Signing Flow ‚Äî Signature
                'signing.sig.title': 'Draw Your Signature',
                'signing.sig.subtitle': 'Use your mouse or finger to draw your signature below.',

                // Signing Flow ‚Äî Keys
                'signing.keys.critical': 'CRITICAL: Save These Keys Before Leaving',
                'signing.keys.explanation': 'A post-quantum SPHINCS+ account was created for you. These keys prove your identity on-chain. Save them now ‚Äî they will be destroyed from this browser.',
                'signing.keys.emailSent': 'Your credentials have also been emailed to',
                'signing.keys.destroy': 'I Have Saved My Keys ‚Äî Destroy From Browser',

                // Signing Flow ‚Äî Complete
                'signing.complete.title': 'Signing Complete',
                'signing.complete.p1': 'Your signature is permanently recorded on the QuantumHarmony blockchain.',
                'signing.complete.p2': 'Your credentials have been emailed to you.',
                'signing.complete.p3': 'Keys have been destroyed from this browser.'
            },
            fr: {
                // Navigation
                'nav.start': 'COMMENCER',
                'nav.attest': 'ATTESTER',
                'nav.verify': 'V√âRIFIER',
                'nav.contracts': 'CONTRATS',
                'nav.qcad': 'QCAD',
                'nav.trust': 'FIDUCIE',
                'nav.account': 'COMPTE',
                'nav.settings': 'PARAM.',
                'nav.pqSecure': 'S√âCURIT√â POST-QUANTIQUE',

                // Start Section
                'start.title': 'Pour Commencer',
                'start.subtitle': 'Bienvenue sur QuantumHarmony - Services notariaux s√©curis√©s post-quantiques',
                'start.welcome.title': 'Bienvenue sur QuantumHarmony',
                'start.welcome.p1': 'QuantumHarmony est la premi√®re blockchain post-quantique con√ßue pour les applications notariales et juridiques. Toutes les transactions sont prot√©g√©es par des signatures SPHINCS+, r√©sistantes aux attaques des futurs ordinateurs quantiques.',
                'start.steps.title': '√âtapes de D√©marrage',
                'start.quickstep.1': '<strong>√âtape 1:</strong> Cr√©ez votre compte ci-dessous (ou importez une cl√© existante)',
                'start.quickstep.2': '<strong>√âtape 2:</strong> Financez votre compte avec des jetons testnet gratuits',
                'start.quickstep.3': '<strong>√âtape 3:</strong> Attestez des documents, cr√©ez des contrats, utilisez QCAD',
                'start.steps.1': '<strong>Obtenir des jetons:</strong> Demandez des jetons QMHY gratuits via le robinet ci-dessous',
                'start.steps.2': '<strong>Cr√©er un compte:</strong> Allez dans COMPTE pour cr√©er un coffre-fort s√©curis√©',
                'start.steps.3': '<strong>Attester des documents:</strong> T√©l√©chargez des documents pour cr√©er des preuves horodat√©es',
                'start.steps.4': '<strong>Utiliser QCAD:</strong> Ouvrez des coffres pour frapper des stablecoins en CAD',
                'start.steps.5': '<strong>Cr√©er des fiducies:</strong> Configurez des comptes fiduciaires (Fideicommis)',
                'start.faucet.title': 'Robinet Testnet',
                'start.faucet.subtitle': 'Obtenez des jetons QMHY gratuits pour commencer',
                'start.faucet.what.title': 'Que sont les jetons QMHY?',
                'start.faucet.what.p1': 'QMHY est le jeton natif de la blockchain QuantumHarmony. Vous avez besoin de QMHY pour:',
                'start.faucet.what.li1': 'Payer les frais de transaction pour l\'attestation de documents',
                'start.faucet.what.li2': 'Cr√©er et signer des contrats Ricardiens',
                'start.faucet.what.li3': 'Ouvrir des coffres QCAD (comme garantie)',
                'start.faucet.what.li4': 'Financer des comptes de fiducie Fideicommis',
                'start.faucet.what.p2': '<strong>Les jetons testnet n\'ont aucune valeur r√©elle</strong> - ils sont uniquement pour les tests.',
                'start.faucet.address.label': 'Votre Adresse (Cl√© Publique)',
                'start.faucet.address.help': 'Entrez votre cl√© publique ou cr√©ez d\'abord un compte. Le robinet enverra 10 QMHY.',
                'start.faucet.button': 'Demander des Jetons',
                'start.faucet.checkBalance': 'V√©rifier le Solde',
                'start.network.title': 'Informations R√©seau',
                'start.network.subtitle': '√âtat actuel du testnet et sp√©cifications',
                'start.network.token': 'Symbole du Jeton',
                'start.network.decimals': 'D√©cimales',
                'start.network.blockTime': 'Temps de Bloc',
                'start.network.consensus': 'Consensus',
                'start.network.signatures': 'Signatures',
                'start.network.validators': 'Validateurs Actifs',
                'start.network.validators.title': 'Validateurs de Production',
                'start.network.blockTime.val': '~3 secondes',
                'start.network.consensus.val': 'Aura + Preuve de Coh√©rence',
                'start.network.signatures.val': 'SPHINCS+-256s (Post-Quantique)',
                'start.network.germany': 'Allemagne',
                'start.network.frankfurt': 'Francfort',

                // √âtape 1 - Cr√©er un Compte
                'start.step1.badge': '√âTAPE 1',
                'start.step1.title': 'Cr√©ez Votre Compte',
                'start.step1.subtitle': 'Votre compte est stock√© localement et s√©curis√© par cryptographie post-quantique',
                'start.step1.noAccount.title': 'Aucun Compte Trouv√©',
                'start.step1.noAccount.p1': 'Vous avez besoin d\'un compte pour utiliser QuantumHarmony. Cr√©ez-en un maintenant - cela ne prend que quelques secondes!',
                'start.step1.name.label': 'Nom du Compte',
                'start.step1.name.help': 'Un nom convivial pour identifier votre compte',
                'start.step1.password.label': 'Mot de Passe',
                'start.step1.password.help': 'Ceci chiffre votre cl√© priv√©e. Ne l\'oubliez pas!',
                'start.step1.confirm.label': 'Confirmer le Mot de Passe',
                'start.step1.button': 'Cr√©er le Compte',
                'start.step1.ready.title': '‚úì Compte Pr√™t',
                'start.step1.ready.account': 'Votre compte:',
                'start.step1.ready.proceed': 'Passez maintenant √† l\'√âtape 2 pour financer votre compte.',

                // √âtape 2 - Financer le Compte
                'start.step2.badge': '√âTAPE 2',
                'start.step2.title': 'Financez Votre Compte',
                'start.step2.subtitle': 'Obtenez des jetons testnet gratuits pour commencer √† utiliser le r√©seau',
                'start.step2.tokens.p1': 'Les jetons QMHY sont n√©cessaires pour payer les frais de transaction. Sur le testnet, ils sont gratuits!',
                'start.step2.address.label': 'Adresse de Votre Compte',
                'start.step2.address.help': 'Sera rempli automatiquement apr√®s la cr√©ation de votre compte',
                'start.step2.requestBtn': 'Demander 100 Jetons QMHY',

                // Attest Section
                'attest.title': 'Attestation de Documents',
                'attest.subtitle': 'Cr√©ez une preuve immuable et horodat√©e que votre document existait √† un moment pr√©cis',
                'attest.what.title': 'Qu\'est-ce que l\'attestation de documents?',
                'attest.what.p1': 'L\'attestation de documents cr√©e un enregistrement permanent et inviolable sur la blockchain QuantumHarmony prouvant que votre document existait √† un moment pr√©cis. Cela peut √™tre utilis√© pour:',
                'attest.what.li1': '<strong>Propri√©t√© Intellectuelle</strong> - Prouver quand vous avez cr√©√© une ≈ìuvre originale',
                'attest.what.li2': '<strong>Documents Juridiques</strong> - Horodater des contrats, accords et dossiers judiciaires',
                'attest.what.li3': '<strong>Dossiers Acad√©miques</strong> - Certifier des dipl√¥mes et relev√©s de notes',
                'attest.what.li4': '<strong>Conformit√©</strong> - Respecter les exigences r√©glementaires d\'horodatage',
                'attest.what.privacy': '<strong>Garantie de Confidentialit√©:</strong> Votre document ne quitte jamais votre navigateur. Seule une empreinte cryptographique (hash) est stock√©e sur la blockchain - le contenu reste enti√®rement priv√©.',
                'attest.warning.title': 'Compte Requis',
                'attest.warning.p1': 'Avant de pouvoir attester des documents, vous devez cr√©er et d√©verrouiller un compte. Allez dans la section <strong>COMPTE</strong> pour cr√©er un coffre-fort s√©curis√©.',
                'attest.step1': 'S√©lectionnez Votre Document',
                'attest.dropzone.text': 'Glissez-d√©posez votre document ici, ou cliquez pour parcourir',
                'attest.dropzone.hint': 'Supporte: Tous types de fichiers (PDF, DOCX, images, etc.) jusqu\'√† 100Mo',
                'attest.file.label': 'Document S√©lectionn√©',
                'attest.file.help': 'C\'est le fichier que vous avez s√©lectionn√© pour l\'attestation',
                'attest.hash.label': 'Hash du Document (SHA-256)',
                'attest.hash.help': 'Cette empreinte unique identifie votre document. Seul ce hash sera stock√© sur la blockchain - le contenu de votre fichier reste priv√©.',
                'attest.step2': 'Choisissez la Cat√©gorie du Document',
                'attest.category.label': 'Cat√©gorie',
                'attest.category.help': 'Cat√©goriser votre document aide √† l\'organisation et la recherche',
                'attest.category.0': 'Dipl√¥me Acad√©mique - Dipl√¥mes, certificats, relev√©s de notes',
                'attest.category.1': 'Document Juridique - Contrats, accords, dossiers judiciaires',
                'attest.category.2': 'Contrat - Accords commerciaux, contrats de service',
                'attest.category.3': 'Propri√©t√© Intellectuelle - Brevets, designs, ≈ìuvres cr√©atives',
                'attest.category.4': 'Document d\'Identit√© - V√©rification d\'identit√©, documents KYC',
                'attest.category.5': 'Document Financier - Factures, re√ßus, relev√©s',
                'attest.category.6': 'Dossier M√©dical - Dossiers de sant√©, ordonnances',
                'attest.category.7': 'Autre - Attestation √† usage g√©n√©ral',
                'attest.desc.label': 'Description (Optionnel)',
                'attest.desc.placeholder': 'Br√®ve description du document',
                'attest.desc.help': 'Une courte description stock√©e sur la blockchain avec votre attestation (max 256 caract√®res)',
                'attest.step3': 'Options de Stockage (Optionnel)',
                'attest.storage.label': 'Stockage du Document',
                'attest.storage.local': 'Local Uniquement - Hash stock√© sur la blockchain, document reste sur votre appareil',
                'attest.storage.ipfs': 'IPFS Public - Document stock√© sur le r√©seau d√©centralis√© (accessible publiquement)',
                'attest.storage.encrypted': 'IPFS Chiffr√© - Document chiffr√© avant stockage (priv√©, n√©cessite une cl√© pour acc√©der)',
                'attest.storage.help': 'Choisissez o√π votre fichier est stock√©. "Local Uniquement" est l\'option la plus priv√©e - seul le hash va sur la blockchain.',
                'attest.ipfs.title': 'Configuration IPFS Requise',
                'attest.ipfs.p1': 'Pour utiliser le stockage IPFS, vous devez configurer vos cl√©s API Pinata dans la section <strong>PARAM√àTRES</strong>. Pinata fournit un stockage fiable et permanent sur le r√©seau IPFS.',
                'attest.step4': 'Soumettre l\'Attestation',
                'attest.submit.info': 'Lorsque vous soumettez, le hash de votre document sera enregistr√© de fa√ßon permanente sur la blockchain QuantumHarmony avec une signature post-quantique SPHINCS+. Cela cr√©e une preuve d\'existence juridiquement recevable.',
                'attest.submit.button': 'Soumettre l\'Attestation sur la Blockchain',
                'attest.history.title': 'Votre Historique d\'Attestations',
                'attest.history.subtitle': 'Documents que vous avez pr√©c√©demment attest√©s',
                'attest.history.info': 'Votre historique d\'attestations est stock√© localement dans votre navigateur. Chaque entr√©e affiche le nom du document, le hash et l\'horodatage. Vous pouvez utiliser ces hashs pour v√©rifier des documents plus tard.',
                'attest.history.empty': 'Aucune attestation pour l\'instant. Attestez votre premier document ci-dessus.',

                // Verify Section
                'verify.title': 'V√©rification de Documents',
                'verify.subtitle': 'V√©rifiez si un document a √©t√© attest√© sur la blockchain et consultez les d√©tails de l\'attestation',
                'verify.how.title': 'Comment Fonctionne la V√©rification',
                'verify.how.p1': 'La v√©rification de documents permet √† quiconque de confirmer qu\'un document sp√©cifique a √©t√© attest√© √† un moment particulier. C\'est utile pour:',
                'verify.how.li1': '<strong>Authenticit√©</strong> - Confirmer qu\'un document n\'a pas √©t√© modifi√©',
                'verify.how.li2': '<strong>Preuve d\'Horodatage</strong> - V√©rifier quand un document existait',
                'verify.how.li3': '<strong>Preuve Juridique</strong> - Utiliser comme preuve dans des litiges',
                'verify.upload.title': 'T√©l√©charger le Document √† V√©rifier',
                'verify.dropzone.text': 'Glissez-d√©posez le document √† v√©rifier, ou cliquez pour parcourir',
                'verify.dropzone.hint': 'Nous calculerons le hash et v√©rifierons s\'il existe sur la blockchain',
                'verify.hash.label': 'Ou Entrez le Hash du Document Directement',
                'verify.hash.placeholder': '0x... (hash SHA-256)',
                'verify.hash.help': 'Si vous avez d√©j√† le hash du document, entrez-le ici',
                'verify.button': 'V√©rifier sur la Blockchain',

                // Contracts Section
                'contracts.title': 'Contrats Ricardiens',
                'contracts.subtitle': 'Cr√©ez et signez des contrats intelligents juridiquement contraignants avec plusieurs parties',
                'contracts.what.title': 'Que sont les Contrats Ricardiens?',
                'contracts.what.p1': 'Les contrats Ricardiens combinent des termes juridiques lisibles par l\'homme avec des signatures cryptographiques. Chaque partie signe le contrat avec sa cl√© SPHINCS+, cr√©ant un accord multi-parties inviolable.',
                'contracts.warning.title': 'Compte Requis',
                'contracts.warning.p1': 'Vous devez d√©verrouiller votre coffre-fort pour cr√©er ou signer des contrats. Allez dans la section <strong>COMPTE</strong>.',
                'contracts.create.button': 'Cr√©er un Nouveau Contrat',
                'contracts.sign.button': 'Signer un Contrat Existant',
                'contracts.view.button': 'Voir les D√©tails du Contrat',
                'contracts.your.title': 'Vos Contrats',
                'contracts.your.subtitle': 'Contrats que vous avez cr√©√©s ou sign√©s',
                'contracts.empty': 'Aucun contrat pour l\'instant. Cr√©ez votre premier contrat ci-dessus.',

                // QCAD Section
                'qcad.title': 'Stablecoin QCAD',
                'qcad.subtitle': 'Stablecoin index√© sur le dollar canadien, garanti par QMHY',
                'qcad.what.title': 'Qu\'est-ce que le QCAD?',
                'qcad.what.p1': 'Le QCAD est un stablecoin d√©centralis√© index√© 1:1 sur le dollar canadien. Il est garanti par des jetons QMHY verrouill√©s dans des coffres √† un ratio minimum de 150%.',
                'qcad.how.title': 'Comment √áa Marche',
                'qcad.how.li1': '<strong>Ouvrir un Coffre:</strong> Verrouillez des jetons QMHY comme garantie pour frapper des QCAD',
                'qcad.how.li2': '<strong>Ratio de Garantie:</strong> Minimum 150% - si vous verrouillez $1500 QMHY, vous pouvez frapper jusqu\'√† 1000 QCAD',
                'qcad.how.li3': '<strong>Liquidation:</strong> Si votre ratio tombe sous 120%, votre coffre peut √™tre liquid√©',
                'qcad.how.li4': '<strong>Frais de Stabilit√©:</strong> 2% d\'int√©r√™t annuel sur les QCAD frapp√©s',
                'qcad.civil.title': 'Conformit√© au Droit Civil (Qu√©bec)',
                'qcad.civil.p1': 'Le QCAD est con√ßu pour √™tre conforme aux dispositions du Code civil du Qu√©bec sur la monnaie √©lectronique et les contrats intelligents, le rendant adapt√© aux applications notariales et juridiques.',
                'qcad.warning.title': 'Compte Requis',
                'qcad.warning.p1': 'Vous devez d√©verrouiller votre coffre-fort dans la section <strong>COMPTE</strong> avant d\'utiliser les fonctionnalit√©s QCAD.',
                'qcad.open.title': 'Ouvrir un Nouveau Coffre',
                'qcad.open.subtitle': 'Verrouillez du QMHY comme garantie pour frapper des QCAD',
                'qcad.open.info.title': 'Cr√©ation d\'un Coffre',
                'qcad.open.info.p1': 'Pour ouvrir un coffre, vous d√©posez des jetons QMHY comme garantie et sp√©cifiez combien de QCAD vous voulez frapper. Le ratio de garantie doit √™tre d\'au moins 150%.',
                'qcad.open.info.example': '<strong>Exemple:</strong> Pour frapper 1,000 QCAD, vous avez besoin d\'au moins 1,500 CAD en garantie QMHY.',
                'qcad.collateral.label': 'Montant de Garantie QMHY',
                'qcad.collateral.placeholder': 'Montant de QMHY √† verrouiller comme garantie',
                'qcad.collateral.help': 'Jetons QMHY √† verrouiller (1 QMHY = 1,000,000,000,000 unit√©s)',
                'qcad.mint.label': 'QCAD √† Frapper',
                'qcad.mint.placeholder': 'Montant de QCAD √† frapper',
                'qcad.mint.help': 'Stablecoin QCAD √† recevoir (minimum 100 QCAD par coffre)',
                'qcad.open.button': 'Ouvrir le Coffre',
                'qcad.manage.title': 'G√©rer un Coffre Existant',
                'qcad.manage.subtitle': 'D√©poser, retirer, frapper plus, ou rembourser la dette de votre coffre',
                'qcad.vaultId.label': 'ID du Coffre',
                'qcad.vaultId.placeholder': 'Entrez l\'ID de votre coffre',
                'qcad.vaultId.help': 'L\'ID du coffre que vous voulez g√©rer',
                'qcad.amount.label': 'Montant',
                'qcad.amount.placeholder': 'Montant pour l\'op√©ration',
                'qcad.amount.help': 'Montant en QMHY (pour d√©p√¥t/retrait) ou QCAD (pour frapper/rembourser)',
                'qcad.deposit.button': 'D√©poser QMHY',
                'qcad.withdraw.button': 'Retirer QMHY',
                'qcad.mintMore.button': 'Frapper QCAD',
                'qcad.repay.button': 'Rembourser QCAD',
                'qcad.close.button': 'Fermer le Coffre',
                'qcad.transfer.title': 'Transf√©rer QCAD',
                'qcad.transfer.subtitle': 'Envoyer des QCAD √† un autre compte',
                'qcad.recipient.label': 'Adresse du Destinataire',
                'qcad.recipient.placeholder': '0x... cl√© publique du destinataire',
                'qcad.recipient.help': 'La cl√© publique du compte recevant les QCAD',
                'qcad.transferAmount.label': 'Montant (QCAD)',
                'qcad.transferAmount.placeholder': 'Montant de QCAD √† envoyer',
                'qcad.transferAmount.help': 'Montant de QCAD √† transf√©rer',
                'qcad.transferButton': 'Transf√©rer QCAD',
                'qcad.liquidate.title': 'Liquider un Coffre Sous-Garanti',
                'qcad.liquidate.subtitle': 'Remboursez la dette d\'un coffre sous 120% pour r√©clamer la garantie',
                'qcad.liquidate.info.title': 'Comment Fonctionne la Liquidation',
                'qcad.liquidate.info.p1': 'Quand le ratio de garantie d\'un coffre tombe sous 120%, n\'importe qui peut le liquider en remboursant la dette QCAD. Le liquidateur re√ßoit la garantie plus un bonus de 13%.',
                'qcad.liquidate.info.warning': '<strong>Attention:</strong> Ne liquidez que les coffres r√©ellement sous-garantis. V√©rifiez le prix actuel QMHY/CAD avant d\'essayer.',
                'qcad.liquidateId.label': 'ID du Coffre √† Liquider',
                'qcad.liquidateId.placeholder': 'Entrez l\'ID du coffre √† liquider',
                'qcad.liquidateId.help': 'L\'ID d\'un coffre sous-garanti',
                'qcad.liquidate.button': 'Liquider le Coffre',

                // Trust Section
                'trust.title': 'Comptes Fid√©icommis',
                'trust.subtitle': 'Comptes fiduciaires conformes au Code civil du Qu√©bec pour la planification successorale',
                'trust.what.title': 'Qu\'est-ce qu\'un Fid√©icommis?',
                'trust.what.p1': 'Un fid√©icommis (latin: "foi confi√©e") est un arrangement fiduciaire de droit civil reconnu au Qu√©bec et dans d\'autres juridictions de droit civil. Il permet √† un <strong>constituant</strong> de mettre de c√¥t√© des actifs pour des b√©n√©ficiaires avec des conditions temporelles.',
                'trust.roles.title': 'R√¥les Cl√©s',
                'trust.roles.li1': '<strong>Constituant:</strong> La personne qui cr√©e et finance la fiducie',
                'trust.roles.li2': '<strong>Fiduciaire:</strong> L\'administrateur g√©rant la fiducie (peut √™tre le constituant)',
                'trust.roles.li3': '<strong>Grev√©:</strong> B√©n√©ficiaire principal qui peut r√©clamer avant la date de d√©clenchement',
                'trust.roles.li4': '<strong>Appel√©:</strong> B√©n√©ficiaire substitut qui re√ßoit les fonds restants apr√®s le d√©clenchement',
                'trust.how.title': 'Comment √áa Marche',
                'trust.how.li1': 'Le constituant cr√©e une fiducie avec un d√©p√¥t initial',
                'trust.how.li2': 'Le grev√© peut r√©clamer des fonds avant le bloc de d√©clenchement (si autoris√©)',
                'trust.how.li3': 'Au bloc de d√©clenchement, les fonds restants vont √† l\'appel√©',
                'trust.how.li4': 'Les fiducies r√©vocables peuvent √™tre annul√©es par le constituant',
                'trust.legal.title': 'Cadre Juridique',
                'trust.legal.p1': 'Cette impl√©mentation suit les articles 1260-1298 du Code civil du Qu√©bec concernant les fiducies. Elle fournit une ex√©cution sur la blockchain des termes de la fiducie avec une s√©curit√© cryptographique post-quantique.',
                'trust.warning.title': 'Compte Requis',
                'trust.warning.p1': 'Vous devez d√©verrouiller votre coffre-fort dans la section <strong>COMPTE</strong> avant de cr√©er ou g√©rer des fiducies.',
                'trust.create.title': 'Cr√©er une Nouvelle Fiducie',
                'trust.create.subtitle': '√âtablir un compte fid√©icommis',
                'trust.create.info.title': 'Param√®tres de la Fiducie',
                'trust.create.info.p1': 'D√©finissez les b√©n√©ficiaires, le calendrier et le financement initial de votre fiducie. La dur√©e minimale est de 1 jour (28,800 blocs √† 3 secondes par bloc).',
                'trust.name.label': 'Nom de la Fiducie',
                'trust.name.placeholder': 'ex: Fonds d\'√âducation Familial',
                'trust.name.help': 'Un nom descriptif pour cette fiducie (max 64 caract√®res)',
                'trust.fiduciary.label': 'Adresse du Fiduciaire',
                'trust.fiduciary.placeholder': '0x... cl√© publique du fiduciaire (peut √™tre la v√¥tre)',
                'trust.fiduciary.help': 'Le compte qui g√©rera la fiducie',
                'trust.greve.label': 'Adresse du Grev√© (B√©n√©ficiaire Principal)',
                'trust.greve.placeholder': '0x... cl√© publique du grev√©',
                'trust.greve.help': 'B√©n√©ficiaire principal qui peut r√©clamer avant le d√©clenchement',
                'trust.appele.label': 'Adresse de l\'Appel√© (B√©n√©ficiaire Substitut)',
                'trust.appele.placeholder': '0x... cl√© publique de l\'appel√©',
                'trust.appele.help': 'Re√ßoit les fonds restants apr√®s le d√©clenchement (doit √™tre diff√©rent du grev√©)',
                'trust.trigger.label': 'Num√©ro de Bloc de D√©clenchement',
                'trust.trigger.placeholder': 'Num√©ro de bloc quand la fiducie transf√®re √† l\'appel√©',
                'trust.trigger.help': '√Ä ~3 secondes/bloc: 28,800 blocs = 1 jour, 864,000 blocs = 30 jours',
                'trust.claimBefore.label': 'Date Limite de R√©clamation du Grev√© (Optionnel)',
                'trust.claimBefore.placeholder': 'Bloc avant lequel le grev√© doit r√©clamer (optionnel)',
                'trust.claimBefore.help': 'Si d√©fini, le grev√© ne peut r√©clamer qu\'avant ce num√©ro de bloc',
                'trust.deposit.label': 'D√©p√¥t Initial (QMHY)',
                'trust.deposit.placeholder': 'QMHY initial pour financer la fiducie',
                'trust.deposit.help': 'D√©p√¥t minimum requis pour cr√©er la fiducie',
                'trust.type.label': 'Type de Fiducie',
                'trust.type.irrevocable': 'Irr√©vocable - Ne peut pas √™tre annul√©e une fois cr√©√©e',
                'trust.type.revocable': 'R√©vocable - Le constituant peut annuler et r√©cup√©rer les fonds',
                'trust.type.help': 'Les fiducies irr√©vocables offrent des garanties plus fortes pour les b√©n√©ficiaires',
                'trust.create.button': 'Cr√©er la Fiducie',
                'trust.manage.title': 'G√©rer la Fiducie',
                'trust.manage.subtitle': 'D√©poser des fonds suppl√©mentaires ou annuler une fiducie r√©vocable',
                'trust.trustId.label': 'ID de la Fiducie',
                'trust.trustId.placeholder': 'Entrez l\'ID de la fiducie',
                'trust.trustId.help': 'L\'ID de la fiducie que vous voulez g√©rer',
                'trust.depositAmount.label': 'Montant du D√©p√¥t (QMHY)',
                'trust.depositAmount.placeholder': 'Montant √† ajouter √† la fiducie',
                'trust.depositAmount.help': 'Fonds suppl√©mentaires √† d√©poser (constituant uniquement)',
                'trust.depositButton': 'D√©poser dans la Fiducie',
                'trust.cancelButton': 'Annuler la Fiducie',
                'trust.claim.title': 'R√©clamer en tant que B√©n√©ficiaire',
                'trust.claim.subtitle': 'Le Grev√© ou l\'Appel√© peut r√©clamer ses fonds',
                'trust.claim.rules.title': 'R√®gles de R√©clamation',
                'trust.claim.rules.li1': '<strong>Grev√©:</strong> Peut r√©clamer des montants partiels avant le bloc de d√©clenchement (ou greve_claim_before si d√©fini)',
                'trust.claim.rules.li2': '<strong>Appel√©:</strong> R√©clame tous les fonds restants apr√®s le bloc de d√©clenchement',
                'trust.claimAmount.label': 'Montant √† R√©clamer (QMHY) - Grev√© Uniquement',
                'trust.claimAmount.placeholder': 'Montant √† r√©clamer (grev√© uniquement)',
                'trust.claimAmount.help': 'Le grev√© peut r√©clamer des montants partiels; l\'appel√© r√©clame tout ce qui reste',
                'trust.claimGreve.button': 'R√©clamer en tant que Grev√©',
                'trust.claimAppele.button': 'R√©clamer en tant qu\'Appel√©',

                // Account Section
                'account.title': 'Gestion du Compte',
                'account.subtitle': 'Cr√©ez et g√©rez votre coffre-fort SPHINCS+ s√©curis√©',
                'account.what.title': 'Qu\'est-ce qu\'un Coffre-Fort?',
                'account.what.p1': 'Un coffre-fort est un fichier chiffr√© contenant votre cl√© priv√©e SPHINCS+. Votre cl√© priv√©e est utilis√©e pour signer des transactions et prouver votre identit√© sur la blockchain.',
                'account.what.li1': '<strong>S√©curit√© Post-Quantique:</strong> Prot√©g√© par des signatures SPHINCS+-256s',
                'account.what.li2': '<strong>Chiffrement AES-256:</strong> Votre cl√© est chiffr√©e avec votre mot de passe',
                'account.what.li3': '<strong>Stockage Local:</strong> Les cl√©s ne quittent jamais votre navigateur',
                'account.security.title': 'Avertissement de S√©curit√©',
                'account.security.p1': '<strong>Ne partagez jamais votre fichier coffre-fort ou votre mot de passe.</strong> Quiconque ayant acc√®s aux deux peut contr√¥ler votre compte et voler vos fonds.',
                'account.create.title': 'Cr√©er un Nouveau Coffre-Fort',
                'account.create.subtitle': 'G√©n√©rer une nouvelle paire de cl√©s SPHINCS+',
                'account.name.label': 'Nom du Compte',
                'account.name.placeholder': 'ex: Mon Compte Principal',
                'account.name.help': 'Un nom convivial pour identifier ce coffre-fort',
                'account.password.label': 'Mot de Passe',
                'account.password.placeholder': 'Mot de passe fort (min 8 caract√®res)',
                'account.password.help': 'Utilis√© pour chiffrer votre cl√© priv√©e. Choisissez un mot de passe fort!',
                'account.confirm.label': 'Confirmer le Mot de Passe',
                'account.confirm.placeholder': 'R√©-entrez votre mot de passe',
                'account.create.button': 'Cr√©er le Coffre-Fort',
                'account.unlock.title': 'D√©verrouiller un Coffre-Fort Existant',
                'account.unlock.subtitle': 'D√©chiffrez votre coffre-fort pour signer des transactions',
                'account.select.label': 'S√©lectionner le Coffre-Fort',
                'account.unlockPassword.label': 'Mot de Passe',
                'account.unlockPassword.placeholder': 'Entrez le mot de passe de votre coffre-fort',
                'account.unlock.button': 'D√©verrouiller',
                'account.lock.button': 'Verrouiller',
                'account.delete.button': 'Supprimer le S√©lectionn√©',
                'account.clearAll.button': 'Effacer Tous les Coffres-Forts',
                'account.info.title': 'Compte Actuel',
                'account.pubkey.label': 'Cl√© Publique',
                'account.transfer.title': 'Transf√©rer QMHY',
                'account.transfer.subtitle': 'Envoyer des jetons √† un autre compte',
                'account.recipient.label': 'Adresse du Destinataire',
                'account.recipient.placeholder': '0x... ou adresse SS58',
                'account.transferAmount.label': 'Montant (QMHY)',
                'account.transferAmount.placeholder': 'Montant √† envoyer',
                'account.transferAmount.help': 'Montant de jetons √† envoyer (1 QMHY = 1,000,000,000,000 unit√©s)',
                'account.transfer.button': 'Envoyer les Jetons',

                // Settings Section
                'settings.title': 'Connexion Blockchain',
                'settings.subtitle': 'Configurez votre connexion au r√©seau blockchain QuantumHarmony',
                'settings.rpc.title': 'Point de Terminaison RPC',
                'settings.rpc.p1': 'Le point de terminaison RPC est l\'URL du n≈ìud blockchain QuantumHarmony avec lequel cette application communique. Par d√©faut, elle se connecte au n≈ìud validateur officiel Alice. Vous pouvez le modifier si vous ex√©cutez votre propre n≈ìud ou vous connectez √† un autre r√©seau.',
                'settings.rpc.label': 'URL du Point de Terminaison RPC',
                'settings.rpc.help': 'L\'URL HTTPS du proxy RPC de la blockchain',
                'settings.save.button': 'Enregistrer le Point de Terminaison',
                'settings.test.button': 'Tester la Connexion',
                'settings.ipfs.title': 'Stockage IPFS (Optionnel)',
                'settings.ipfs.subtitle': 'Configurez Pinata pour le stockage d√©centralis√© de documents',
                'settings.ipfs.what.title': 'Qu\'est-ce qu\'IPFS?',
                'settings.ipfs.what.p1': 'IPFS (InterPlanetary File System) est un r√©seau de stockage d√©centralis√©. Lorsque vous t√©l√©chargez un document sur IPFS, il est distribu√© sur plusieurs n≈ìuds dans le monde, assurant disponibilit√© et permanence.',
                'settings.ipfs.pinata.title': 'Pinata',
                'settings.ipfs.pinata.p1': 'Pinata est un service d\'√©pinglage IPFS fiable qui assure que vos fichiers restent disponibles. Vous aurez besoin d\'un compte Pinata gratuit pour utiliser les fonctionnalit√©s IPFS:',
                'settings.ipfs.pinata.li1': 'Allez sur <strong>pinata.cloud</strong> et cr√©ez un compte gratuit',
                'settings.ipfs.pinata.li2': 'Naviguez vers Cl√©s API dans votre tableau de bord',
                'settings.ipfs.pinata.li3': 'Cr√©ez une nouvelle cl√© API avec des permissions d\'√©pinglage',
                'settings.ipfs.pinata.li4': 'Copiez la Cl√© API et la Cl√© Secr√®te ici',
                'settings.ipfs.apiKey.label': 'Cl√© API Pinata',
                'settings.ipfs.apiKey.placeholder': 'Votre Cl√© API du tableau de bord Pinata',
                'settings.ipfs.apiKey.help': 'Trouv√©e dans votre tableau de bord Pinata sous Cl√©s API',
                'settings.ipfs.secret.label': 'Cl√© Secr√®te Pinata',
                'settings.ipfs.secret.placeholder': 'Votre Cl√© Secr√®te de Pinata',
                'settings.ipfs.secret.help': 'Gardez-la secr√®te - elle autorise les t√©l√©chargements vers votre compte Pinata',
                'settings.ipfs.save.button': 'Enregistrer les Param√®tres IPFS',
                'settings.ipfs.test.button': 'Tester la Connexion Pinata',
                'settings.about.title': '√Ä Propos de Cette Application',
                'settings.about.name': 'Service Notarial QuantumHarmony',
                'settings.about.p1': 'Cette application fournit une attestation de documents et une signature de contrats s√©curis√©es post-quantiques en utilisant la blockchain QuantumHarmony.',
                'settings.about.security.title': 'Fonctionnalit√©s de S√©curit√©',
                'settings.about.security.li1': '<strong>Signatures SPHINCS+:</strong> S√©curis√©es post-quantiques, r√©sistantes aux attaques des ordinateurs quantiques',
                'settings.about.security.li2': '<strong>Hachage SHA-256:</strong> Empreinte cryptographique standard de l\'industrie pour les documents',
                'settings.about.security.li3': '<strong>Chiffrement AES-256-GCM:</strong> Chiffrement de niveau militaire pour la protection des coffres-forts',
                'settings.about.security.li4': '<strong>Traitement C√¥t√© Client:</strong> Vos documents et cl√©s ne quittent jamais votre navigateur',
                'settings.about.opensource.title': 'Code Source Ouvert',
                'settings.about.opensource.p1': 'Cette application est open source. Consultez le code et contribuez sur:',
                'settings.about.opensource.url': 'github.com/Paraxiom/quantumharmony-notarial',

                // Signing Flow ‚Äî KYC
                'signing.kyc.title': 'Enregistrement d\'identit√©',
                'signing.kyc.subtitle': 'Veuillez fournir vos coordonn√©es. Vos identifiants vous seront envoy√©s par courriel apr√®s la signature.',
                'signing.kyc.fullName': 'Nom l√©gal complet *',
                'signing.kyc.email': 'Adresse courriel *',
                'signing.kyc.emailHelp': 'Vos identifiants blockchain seront envoy√©s √† cette adresse',
                'signing.kyc.phone': 'T√©l√©phone (Optionnel)',
                'signing.kyc.address': 'Adresse postale *',
                'signing.kyc.dob': 'Date de naissance *',
                'signing.kyc.continue': 'Continuer vers la r√©vision du document',

                // Signing Flow ‚Äî Review
                'signing.review.title': 'R√©visez cet accord',
                'signing.review.subtitle': 'Examinez les d√©tails du contrat ci-dessous. Prenez votre temps ‚Äî vous pouvez fermer cette page et revenir plus tard.',
                'signing.review.download': 'T√©l√©charger le r√©sum√© du contrat (.txt)',
                'signing.review.patience': 'Prenez votre temps. Vous pouvez fermer cette page et revenir plus tard avec le m√™me lien.',
                'signing.review.ready': 'J\'ai r√©vis√© le document ‚Äî Pr√™t √† signer',

                // Signing Flow ‚Äî Signature
                'signing.sig.title': 'Dessinez votre signature',
                'signing.sig.subtitle': 'Utilisez votre souris ou votre doigt pour dessiner votre signature ci-dessous.',

                // Signing Flow ‚Äî Keys
                'signing.keys.critical': 'CRITIQUE: Sauvegardez ces cl√©s avant de quitter',
                'signing.keys.explanation': 'Un compte SPHINCS+ post-quantique a √©t√© cr√©√© pour vous. Ces cl√©s prouvent votre identit√© sur la cha√Æne. Sauvegardez-les maintenant ‚Äî elles seront d√©truites de ce navigateur.',
                'signing.keys.emailSent': 'Vos identifiants ont √©galement √©t√© envoy√©s par courriel √†',
                'signing.keys.destroy': 'J\'ai sauvegard√© mes cl√©s ‚Äî D√©truire du navigateur',

                // Signing Flow ‚Äî Complete
                'signing.complete.title': 'Signature termin√©e',
                'signing.complete.p1': 'Votre signature est enregistr√©e de fa√ßon permanente sur la blockchain QuantumHarmony.',
                'signing.complete.p2': 'Vos identifiants vous ont √©t√© envoy√©s par courriel.',
                'signing.complete.p3': 'Les cl√©s ont √©t√© d√©truites de ce navigateur.'
            }
        };

        function toggleLanguage() {
            currentLang = currentLang === 'en' ? 'fr' : 'en';
            localStorage.setItem('qh_lang', currentLang);
            applyTranslations();
            document.getElementById('langToggle').textContent = currentLang.toUpperCase();
        }

        function applyTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const translation = translations[currentLang][key];
                if (translation) {
                    el.innerHTML = translation;
                }
            });
        }

        // Apply translations on load
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('langToggle').textContent = currentLang.toUpperCase();
            applyTranslations();
        });

        // ==================== Faucet Functions ====================

        async function requestFaucet() {
            // Always use the hex public key for funding
            let pubKey = unlockedKey ? unlockedKey.publicKey : null;

            if (!pubKey) {
                showResult('faucetResult', 'error', currentLang === 'fr'
                    ? 'Veuillez d√©verrouiller votre compte dans la section COMPTE.'
                    : 'Please unlock your account in the ACCOUNT section.');
                return;
            }

            try {
                showResult('faucetResult', 'success', currentLang === 'fr'
                    ? 'Envoi de 100 QMHY depuis le validateur...'
                    : 'Sending 100 QMHY from validator...');

                const result = await fundAccountDirect(pubKey, 100);

                if (result && (result.success || result.hash)) {
                    showResult('faucetResult', 'success', currentLang === 'fr'
                        ? `100 QMHY envoy√©s! TX: ${(result.hash || '').substring(0, 20)}...`
                        : `100 QMHY sent! TX: ${(result.hash || '').substring(0, 20)}...`);
                } else {
                    showResult('faucetResult', 'error', currentLang === 'fr'
                        ? 'Le transfert a √©chou√©: ' + JSON.stringify(result)
                        : 'Transfer failed: ' + JSON.stringify(result));
                }
            } catch (e) {
                showResult('faucetResult', 'error', currentLang === 'fr'
                    ? 'Impossible de financer le compte: ' + e.message
                    : 'Failed to fund account: ' + e.message);
            }
        }

        async function checkBalance() {
            let address = document.getElementById('faucetAddress').value.trim();

            if (!address && unlockedKey) {
                address = unlockedKey.publicKey;
                document.getElementById('faucetAddress').value = address;
            }

            if (!address) {
                showResult('faucetResult', 'error', currentLang === 'fr'
                    ? 'Veuillez entrer une adresse.'
                    : 'Please enter an address.');
                return;
            }

            try {
                showResult('faucetResult', 'success', currentLang === 'fr'
                    ? 'V√©rification du solde...'
                    : 'Checking balance...');

                const result = await rpcCall('gateway_balance', [address]);

                if (result.error) {
                    showResult('faucetResult', 'error', 'Error: ' + (result.error.message || JSON.stringify(result.error)));
                } else {
                    const balance = result.result;
                    // Balance is in smallest units (10^12 = 1 QMHY)
                    const balanceNum = typeof balance === 'string' ? parseInt(balance) : balance;
                    const qmhyBalance = (balanceNum / 1e12).toFixed(4);

                    showResult('faucetResult', 'success', currentLang === 'fr'
                        ? `<strong>Solde:</strong> ${qmhyBalance} QMHY<br><small>(${balanceNum.toLocaleString()} unit√©s)</small>`
                        : `<strong>Balance:</strong> ${qmhyBalance} QMHY<br><small>(${balanceNum.toLocaleString()} units)</small>`);
                }
            } catch (e) {
                showResult('faucetResult', 'error', 'Error: ' + e.message);
            }
        }

        // ==================== QCAD Stablecoin Functions ====================

        // Convert QMHY amount to smallest units (1 QMHY = 10^12 units)
        function qmhyToUnits(amount) {
            return BigInt(Math.floor(parseFloat(amount) * 1e12));
        }

        // Convert QCAD amount to smallest units (assume 12 decimals like QMHY)
        function qcadToUnits(amount) {
            return BigInt(Math.floor(parseFloat(amount) * 1e12));
        }

        // Encode a u64 as compact SCALE
        function encodeCompactU64(value) {
            const n = BigInt(value);
            if (n < 64n) {
                return [(Number(n) << 2)];
            } else if (n < 16384n) {
                const v = (Number(n) << 2) | 1;
                return [v & 0xff, (v >> 8) & 0xff];
            } else if (n < 1073741824n) {
                const v = (Number(n) << 2) | 2;
                return [v & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff];
            } else {
                // Big integer mode
                const bytes = [];
                let temp = n;
                while (temp > 0n) {
                    bytes.push(Number(temp & 0xffn));
                    temp >>= 8n;
                }
                while (bytes.length < 8) bytes.push(0);
                return [3 + ((bytes.length - 4) << 2), ...bytes];
            }
        }

        // Encode a u128 as compact SCALE
        function encodeCompactU128(value) {
            const n = BigInt(value);
            if (n < 64n) {
                return [(Number(n) << 2)];
            } else if (n < 16384n) {
                const v = (Number(n) << 2) | 1;
                return [v & 0xff, (v >> 8) & 0xff];
            } else if (n < 1073741824n) {
                const v = (Number(n) << 2) | 2;
                return [v & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff];
            } else {
                // Big integer mode for u128 ‚Äî must use minimal byte count (Substrate canonical check)
                const bytes = [];
                let temp = n;
                while (temp > 0n) {
                    bytes.push(Number(temp & 0xffn));
                    temp >>= 8n;
                }
                // No padding ‚Äî Substrate rejects non-minimal compact encodings
                return [3 + ((bytes.length - 4) << 2), ...bytes];
            }
        }

        // Build stablecoin call data
        function buildStablecoinCall(callIndex, params) {
            let callData = [STABLECOIN_PALLET_INDEX, callIndex];

            switch (callIndex) {
                case 0: // open_vault(collateral, initial_debt)
                    callData.push(...encodeCompactU128(params.collateral));
                    callData.push(...encodeCompactU128(params.debt));
                    break;
                case 1: // deposit_collateral(vault_id, amount)
                    callData.push(...encodeCompactU64(params.vaultId));
                    callData.push(...encodeCompactU128(params.amount));
                    break;
                case 2: // withdraw_collateral(vault_id, amount)
                    callData.push(...encodeCompactU64(params.vaultId));
                    callData.push(...encodeCompactU128(params.amount));
                    break;
                case 3: // mint_qcad(vault_id, amount)
                    callData.push(...encodeCompactU64(params.vaultId));
                    callData.push(...encodeCompactU128(params.amount));
                    break;
                case 4: // repay_qcad(vault_id, amount)
                    callData.push(...encodeCompactU64(params.vaultId));
                    callData.push(...encodeCompactU128(params.amount));
                    break;
                case 5: // close_vault(vault_id)
                    callData.push(...encodeCompactU64(params.vaultId));
                    break;
                case 6: // liquidate(vault_id)
                    callData.push(...encodeCompactU64(params.vaultId));
                    break;
                case 7: // transfer_qcad(to, amount)
                    // AccountId is 64 bytes for SPHINCS+
                    const toBytes = hexToBytes(params.to);
                    callData.push(...toBytes);
                    callData.push(...encodeCompactU128(params.amount));
                    break;
            }

            return '0x' + callData.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Convert hex string to bytes array
        function hexToBytes(hex) {
            const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
            const bytes = [];
            for (let i = 0; i < cleanHex.length; i += 2) {
                bytes.push(parseInt(cleanHex.substr(i, 2), 16));
            }
            return bytes;
        }

        async function openVault() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore first');
                showResult('openVaultResult', 'error', 'Please unlock your keystore first.');
                return;
            }

            const collateral = document.getElementById('vaultCollateral').value;
            const debt = document.getElementById('vaultDebt').value;

            if (!collateral || !debt) {
                showToast('warning', 'Missing Amounts', 'Enter collateral and debt amounts');
                showResult('openVaultResult', 'error', 'Please enter both collateral and debt amounts.');
                return;
            }

            const btn = document.getElementById('openVaultBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('openVaultResult', 'success', 'Opening vault...');

                    const callData = buildStablecoinCall(0, {
                        collateral: qmhyToUnits(collateral),
                        debt: qcadToUnits(debt)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('openVaultResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Vault Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('openVaultResult', 'success',
                            `Vault opened successfully!<br>` +
                            `Collateral: ${collateral} QMHY<br>` +
                            `Minted: ${debt} QCAD<br>` +
                            `Transaction: ${result.result?.tx_hash || 'submitted'}`
                        );
                        showToast('success', 'Vault Opened', `Minted ${debt} QCAD`);
                    }
                } catch (e) {
                    showResult('openVaultResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Vault Error', e.message);
                }
            });
        }

        async function depositCollateral() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const vaultId = document.getElementById('manageVaultId').value;
            const amount = document.getElementById('vaultAmount').value;

            if (!vaultId || !amount) {
                showToast('warning', 'Missing Fields', 'Enter vault ID and amount');
                showResult('manageVaultResult', 'error', 'Please enter vault ID and amount.');
                return;
            }

            const btn = document.getElementById('depositCollateralBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageVaultResult', 'success', 'Depositing collateral...');

                    const callData = buildStablecoinCall(1, {
                        vaultId: BigInt(vaultId),
                        amount: qmhyToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageVaultResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Deposit Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageVaultResult', 'success', `Deposited ${amount} QMHY to vault #${vaultId}`);
                        showToast('success', 'Deposit Complete', `${amount} QMHY added`);
                    }
                } catch (e) {
                    showResult('manageVaultResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Deposit Error', e.message);
                }
            });
        }

        async function withdrawCollateral() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const vaultId = document.getElementById('manageVaultId').value;
            const amount = document.getElementById('vaultAmount').value;

            if (!vaultId || !amount) {
                showToast('warning', 'Missing Fields', 'Enter vault ID and amount');
                showResult('manageVaultResult', 'error', 'Please enter vault ID and amount.');
                return;
            }

            const btn = document.getElementById('withdrawCollateralBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageVaultResult', 'success', 'Withdrawing collateral...');

                    const callData = buildStablecoinCall(2, {
                        vaultId: BigInt(vaultId),
                        amount: qmhyToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageVaultResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Withdrawal Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageVaultResult', 'success', `Withdrew ${amount} QMHY from vault #${vaultId}`);
                        showToast('success', 'Withdrawal Complete', `${amount} QMHY withdrawn`);
                    }
                } catch (e) {
                    showResult('manageVaultResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Withdrawal Error', e.message);
                }
            });
        }

        async function mintMoreQcad() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const vaultId = document.getElementById('manageVaultId').value;
            const amount = document.getElementById('vaultAmount').value;

            if (!vaultId || !amount) {
                showToast('warning', 'Missing Fields', 'Enter vault ID and QCAD amount');
                showResult('manageVaultResult', 'error', 'Please enter vault ID and QCAD amount.');
                return;
            }

            const btn = document.getElementById('mintMoreBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageVaultResult', 'success', 'Minting QCAD...');

                    const callData = buildStablecoinCall(3, {
                        vaultId: BigInt(vaultId),
                        amount: qcadToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageVaultResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Mint Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageVaultResult', 'success', `Minted ${amount} QCAD from vault #${vaultId}`);
                        showToast('success', 'QCAD Minted', `${amount} QCAD created`);
                    }
                } catch (e) {
                    showResult('manageVaultResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Mint Error', e.message);
                }
            });
        }

        async function repayQcad() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const vaultId = document.getElementById('manageVaultId').value;
            const amount = document.getElementById('vaultAmount').value;

            if (!vaultId || !amount) {
                showToast('warning', 'Missing Fields', 'Enter vault ID and QCAD amount');
                showResult('manageVaultResult', 'error', 'Please enter vault ID and QCAD amount.');
                return;
            }

            const btn = document.getElementById('repayBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageVaultResult', 'success', 'Repaying QCAD...');

                    const callData = buildStablecoinCall(4, {
                        vaultId: BigInt(vaultId),
                        amount: qcadToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageVaultResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Repay Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageVaultResult', 'success', `Repaid ${amount} QCAD to vault #${vaultId}`);
                        showToast('success', 'Repayment Complete', `${amount} QCAD repaid`);
                    }
                } catch (e) {
                    showResult('manageVaultResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Repay Error', e.message);
                }
            });
        }

        async function closeVault() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const vaultId = document.getElementById('manageVaultId').value;

            if (!vaultId) {
                showToast('warning', 'Missing Vault ID', 'Enter vault ID to close');
                showResult('manageVaultResult', 'error', 'Please enter vault ID.');
                return;
            }

            const btn = document.getElementById('closeVaultBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageVaultResult', 'success', 'Closing vault...');

                    const callData = buildStablecoinCall(5, {
                        vaultId: BigInt(vaultId)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageVaultResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Close Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageVaultResult', 'success', `Vault #${vaultId} closed successfully. Collateral returned.`);
                        showToast('success', 'Vault Closed', 'Collateral returned');
                    }
                } catch (e) {
                    showResult('manageVaultResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Close Error', e.message);
                }
            });
        }

        async function transferQcad() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const recipient = document.getElementById('qcadRecipient').value;
            const amount = document.getElementById('qcadTransferAmount').value;

            if (!recipient || !amount) {
                showToast('warning', 'Missing Fields', 'Enter recipient and amount');
                showResult('transferQcadResult', 'error', 'Please enter recipient and amount.');
                return;
            }

            if (!validateSS58(recipient)) {
                showToast('error', 'Invalid Address', 'Recipient must be a valid SS58 address');
                return;
            }

            const btn = document.getElementById('transferQcadBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('transferQcadResult', 'success', 'Transferring QCAD...');

                    const callData = buildStablecoinCall(7, {
                        to: recipient,
                        amount: qcadToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('transferQcadResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Transfer Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('transferQcadResult', 'success', `Transferred ${amount} QCAD to ${recipient.substring(0, 20)}...`);
                        showToast('success', 'Transfer Complete', `${amount} QCAD sent`);
                    }
                } catch (e) {
                    showResult('transferQcadResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Transfer Error', e.message);
                }
            });
        }

        async function liquidateVault() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const vaultId = document.getElementById('liquidateVaultId').value;

            if (!vaultId) {
                showToast('warning', 'Missing Vault ID', 'Enter vault ID to liquidate');
                showResult('liquidateResult', 'error', 'Please enter vault ID to liquidate.');
                return;
            }

            const btn = document.getElementById('liquidateBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('liquidateResult', 'success', 'Liquidating vault...');

                    const callData = buildStablecoinCall(6, {
                        vaultId: BigInt(vaultId)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('liquidateResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Liquidation Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('liquidateResult', 'success', `Vault #${vaultId} liquidated! You received the collateral minus debt.`);
                        showToast('success', 'Vault Liquidated', 'Collateral claimed');
                    }
                } catch (e) {
                    showResult('liquidateResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Liquidation Error', e.message);
                }
            });
        }

        // ==================== QCAD Price Reporter & Queue Functions ====================

        // Price reporters data (will be fetched from chain)
        let priceReporters = [
            { id: 'boc', name: 'Bank of Canada Feed', price: 1.0000, reputation: 98.7, online: true },
            { id: 'chainlink', name: 'Chainlink CAD/USD', price: 1.0002, reputation: 97.2, online: true },
            { id: 'paraxiom', name: 'Paraxiom Oracle', price: 0.9998, reputation: 99.1, online: true },
            { id: 'coingecko', name: 'CoinGecko API', price: 1.0015, reputation: 82.4, online: true }
        ];

        // Calculate median price from selected reporters
        function calculateMedianPrice() {
            const selected = [];
            if (document.getElementById('reporter1')?.checked) selected.push(priceReporters[0].price);
            if (document.getElementById('reporter2')?.checked) selected.push(priceReporters[1].price);
            if (document.getElementById('reporter3')?.checked) selected.push(priceReporters[2].price);
            if (document.getElementById('reporter4')?.checked) selected.push(priceReporters[3].price);

            if (selected.length === 0) return 0;

            selected.sort((a, b) => a - b);
            const mid = Math.floor(selected.length / 2);
            const median = selected.length % 2 !== 0
                ? selected[mid]
                : (selected[mid - 1] + selected[mid]) / 2;

            return median.toFixed(4);
        }

        // Update median price display when reporters change
        function updateMedianPrice() {
            const median = calculateMedianPrice();
            const medianEl = document.getElementById('medianPrice');
            if (medianEl) {
                medianEl.textContent = median + ' CAD';
            }
        }

        // Add event listeners to reporter checkboxes
        document.querySelectorAll('#reporterTable input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateMedianPrice);
        });

        // Refresh price feeds from chain/oracles
        async function refreshPriceFeeds() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Refreshing...';

            try {
                // Simulate fetching from chain
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Update with simulated real-time data
                priceReporters[0].price = 1.0000 + (Math.random() - 0.5) * 0.002;
                priceReporters[1].price = 1.0000 + (Math.random() - 0.5) * 0.003;
                priceReporters[2].price = 1.0000 + (Math.random() - 0.5) * 0.002;
                priceReporters[3].price = 1.0000 + (Math.random() - 0.5) * 0.004;

                // Update table
                const rows = document.querySelectorAll('#reporterTable tr');
                rows.forEach((row, i) => {
                    const priceCell = row.querySelectorAll('td')[1];
                    if (priceCell) {
                        priceCell.textContent = priceReporters[i].price.toFixed(4) + ' CAD';
                    }
                });

                // Update median
                updateMedianPrice();

                // Update last block
                const blockEl = document.getElementById('priceLastUpdate');
                if (blockEl) {
                    const block = Math.floor(Math.random() * 100000) + 1200000;
                    blockEl.textContent = 'Block #' + block.toLocaleString();
                }

                btn.textContent = 'Refresh Price Feeds';
                btn.disabled = false;
            } catch (e) {
                btn.textContent = 'Refresh Failed';
                setTimeout(() => {
                    btn.textContent = 'Refresh Price Feeds';
                    btn.disabled = false;
                }, 2000);
            }
        }

        // Local priority queue state
        let localQueue = {
            pending: [],
            vetting: [],
            approved: []
        };

        // Add transaction to local queue
        function addToQueue(tx) {
            tx.id = 'tx_' + Date.now();
            tx.status = 'pending';
            tx.timestamp = new Date();
            localQueue.pending.push(tx);
            updateQueueDisplay();
            return tx.id;
        }

        // Update queue display
        function updateQueueDisplay() {
            document.getElementById('queuePending').textContent = localQueue.pending.length;
            document.getElementById('queueVetting').textContent = localQueue.vetting.length;
            document.getElementById('queueApproved').textContent = localQueue.approved.length;

            const listEl = document.getElementById('pendingTxList');
            if (localQueue.pending.length === 0 && localQueue.vetting.length === 0) {
                listEl.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 20px;">No pending transactions</div>';
            } else {
                let html = '';
                [...localQueue.pending, ...localQueue.vetting].forEach(tx => {
                    const statusColor = tx.status === 'pending' ? 'var(--accent)' : 'var(--warning)';
                    const statusText = tx.status === 'pending' ? 'PENDING' : 'VETTING';
                    html += `<div style="display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <div>
                            <span style="color: var(--accent); font-weight: bold;">${tx.type}</span>
                            <span style="color: var(--muted); margin-left: 8px;">${tx.id.substring(0, 12)}...</span>
                        </div>
                        <div>
                            <span style="color: ${statusColor}; font-size: 11px;">${statusText}</span>
                        </div>
                    </div>`;
                });
                listEl.innerHTML = html;
            }
        }

        // Simulate transaction vetting progress
        function simulateVetting() {
            // Move pending to vetting
            if (localQueue.pending.length > 0) {
                const tx = localQueue.pending.shift();
                tx.status = 'vetting';
                localQueue.vetting.push(tx);
                updateQueueDisplay();
            }

            // Move vetting to approved (after simulated validator approval)
            setTimeout(() => {
                if (localQueue.vetting.length > 0) {
                    const tx = localQueue.vetting.shift();
                    tx.status = 'approved';
                    localQueue.approved.push(tx);
                    updateQueueDisplay();
                }
            }, 2000);
        }

        // Update current block number periodically
        async function updateBlockNumber() {
            try {
                const result = await rpcCall('chain_getHeader', []);
                if (result && result.number) {
                    const blockNum = parseInt(result.number, 16);
                    document.getElementById('currentBlock').textContent = '#' + blockNum.toLocaleString();
                }
            } catch (e) {
                // Silently fail
            }
        }

        // Initialize QCAD periodic updates
        setInterval(updateBlockNumber, 3000);

        // ==================== Fideicommis Trust Functions ====================

        // Build fideicommis call data
        function buildFideicommisCall(callIndex, params) {
            let callData = [FIDEICOMMIS_PALLET_INDEX, callIndex];

            switch (callIndex) {
                case 0: // create(name, fiduciary, greve, appele, trigger_block, greve_claim_before, initial_deposit, revocable)
                    // name: Vec<u8>
                    const nameBytes = new TextEncoder().encode(params.name);
                    callData.push(...encodeCompactU64(nameBytes.length));
                    callData.push(...nameBytes);
                    // fiduciary: AccountId (64 bytes)
                    callData.push(...hexToBytes(params.fiduciary));
                    // greve: AccountId (64 bytes)
                    callData.push(...hexToBytes(params.greve));
                    // appele: AccountId (64 bytes)
                    callData.push(...hexToBytes(params.appele));
                    // trigger_block: u32
                    const triggerBlock = parseInt(params.triggerBlock);
                    callData.push(triggerBlock & 0xff, (triggerBlock >> 8) & 0xff, (triggerBlock >> 16) & 0xff, (triggerBlock >> 24) & 0xff);
                    // greve_claim_before: Option<u32>
                    if (params.claimBefore && params.claimBefore > 0) {
                        callData.push(1); // Some
                        const claimBefore = parseInt(params.claimBefore);
                        callData.push(claimBefore & 0xff, (claimBefore >> 8) & 0xff, (claimBefore >> 16) & 0xff, (claimBefore >> 24) & 0xff);
                    } else {
                        callData.push(0); // None
                    }
                    // initial_deposit: Balance
                    callData.push(...encodeCompactU128(params.deposit));
                    // revocable: bool
                    callData.push(params.revocable ? 1 : 0);
                    break;

                case 1: // deposit(trust_id, amount)
                    callData.push(...encodeCompactU64(params.trustId));
                    callData.push(...encodeCompactU128(params.amount));
                    break;

                case 2: // claim_as_greve(trust_id, amount)
                    callData.push(...encodeCompactU64(params.trustId));
                    callData.push(...encodeCompactU128(params.amount));
                    break;

                case 3: // claim_as_appele(trust_id)
                    callData.push(...encodeCompactU64(params.trustId));
                    break;

                case 4: // cancel(trust_id)
                    callData.push(...encodeCompactU64(params.trustId));
                    break;
            }

            return '0x' + callData.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        async function createTrust() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                showResult('createTrustResult', 'error', 'Please unlock your keystore first.');
                return;
            }

            const name = document.getElementById('trustName').value;
            const fiduciary = document.getElementById('trustFiduciary').value;
            const greve = document.getElementById('trustGreve').value;
            const appele = document.getElementById('trustAppele').value;
            const triggerBlock = document.getElementById('trustTriggerBlock').value;
            const claimBefore = document.getElementById('trustClaimBefore').value;
            const deposit = document.getElementById('trustDeposit').value;
            const revocable = document.getElementById('trustRevocable').value === 'true';

            if (!name || !fiduciary || !greve || !appele || !triggerBlock || !deposit) {
                showToast('warning', 'Missing Fields', 'Please fill in all required fields');
                showResult('createTrustResult', 'error', 'Please fill in all required fields.');
                return;
            }

            if (greve === appele) {
                showToast('error', 'Invalid Parties', 'Greve and Appele must be different');
                showResult('createTrustResult', 'error', 'Greve and Appele must be different addresses.');
                return;
            }

            const btn = document.getElementById('createTrustBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('createTrustResult', 'success', 'Creating trust...');

                    const callData = buildFideicommisCall(0, {
                        name: name,
                        fiduciary: fiduciary,
                        greve: greve,
                        appele: appele,
                        triggerBlock: triggerBlock,
                        claimBefore: claimBefore || 0,
                        deposit: qmhyToUnits(deposit),
                        revocable: revocable
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('createTrustResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Trust Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('createTrustResult', 'success',
                            `Trust "${name}" created successfully!<br>` +
                            `Initial Deposit: ${deposit} QMHY<br>` +
                            `Trigger Block: ${triggerBlock}<br>` +
                            `Type: ${revocable ? 'Revocable' : 'Irrevocable'}<br>` +
                            `Transaction: ${result.result?.tx_hash || 'submitted'}`
                        );
                        showToast('success', 'Trust Created', `"${name}" established`);
                    }
                } catch (e) {
                    showResult('createTrustResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Trust Error', e.message);
                }
            });
        }

        async function depositToTrust() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const trustId = document.getElementById('manageTrustId').value;
            const amount = document.getElementById('trustDepositAmount').value;

            if (!trustId || !amount) {
                showToast('warning', 'Missing Fields', 'Enter trust ID and amount');
                showResult('manageTrustResult', 'error', 'Please enter trust ID and amount.');
                return;
            }

            const btn = document.getElementById('depositTrustBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageTrustResult', 'success', 'Depositing to trust...');

                    const callData = buildFideicommisCall(1, {
                        trustId: BigInt(trustId),
                        amount: qmhyToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageTrustResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Deposit Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageTrustResult', 'success', `Deposited ${amount} QMHY to trust #${trustId}`);
                        showToast('success', 'Deposit Complete', `${amount} QMHY added to trust`);
                    }
                } catch (e) {
                    showResult('manageTrustResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Deposit Error', e.message);
                }
            });
        }

        async function cancelTrust() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const trustId = document.getElementById('manageTrustId').value;

            if (!trustId) {
                showToast('warning', 'Missing Trust ID', 'Enter trust ID to cancel');
                showResult('manageTrustResult', 'error', 'Please enter trust ID.');
                return;
            }

            const btn = document.getElementById('cancelTrustBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('manageTrustResult', 'success', 'Cancelling trust...');

                    const callData = buildFideicommisCall(4, {
                        trustId: BigInt(trustId)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('manageTrustResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Cancel Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('manageTrustResult', 'success', `Trust #${trustId} cancelled. Funds returned to constituant.`);
                        showToast('success', 'Trust Cancelled', 'Funds returned');
                    }
                } catch (e) {
                    showResult('manageTrustResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Cancel Error', e.message);
                }
            });
        }

        async function claimAsGreve() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const trustId = document.getElementById('claimTrustId').value;
            const amount = document.getElementById('greveClaimAmount').value;

            if (!trustId || !amount) {
                showToast('warning', 'Missing Fields', 'Enter trust ID and claim amount');
                showResult('claimTrustResult', 'error', 'Please enter trust ID and claim amount.');
                return;
            }

            const btn = document.getElementById('claimGreveBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('claimTrustResult', 'success', 'Claiming as greve...');

                    const callData = buildFideicommisCall(2, {
                        trustId: BigInt(trustId),
                        amount: qmhyToUnits(amount)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('claimTrustResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Claim Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('claimTrustResult', 'success', `Claimed ${amount} QMHY from trust #${trustId} as greve.`);
                        showToast('success', 'Claim Successful', `${amount} QMHY claimed`);
                    }
                } catch (e) {
                    showResult('claimTrustResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Claim Error', e.message);
                }
            });
        }

        async function claimAsAppele() {
            if (!unlockedKey) {
                showToast('warning', 'Keystore Required', 'Please unlock your keystore');
                return;
            }

            const trustId = document.getElementById('claimTrustId').value;

            if (!trustId) {
                showToast('warning', 'Missing Trust ID', 'Enter trust ID to claim');
                showResult('claimTrustResult', 'error', 'Please enter trust ID.');
                return;
            }

            const btn = document.getElementById('claimAppeleBtn');

            await withLoading(btn, async () => {
                try {
                    showResult('claimTrustResult', 'success', 'Claiming as appele...');

                    const callData = buildFideicommisCall(3, {
                        trustId: BigInt(trustId)
                    });

                    const result = await rpcCall('quantumharmony_submitSignedExtrinsic', [{
                        call_data: callData,
                        public_key: unlockedKey.publicKey,
                        secret_key: unlockedKey.secretKey
                    }]);

                    if (result.error) {
                        showResult('claimTrustResult', 'error', 'Failed: ' + (result.error.message || JSON.stringify(result.error)));
                        showToast('error', 'Claim Failed', result.error.message || 'Transaction failed');
                    } else {
                        showResult('claimTrustResult', 'success', `Claimed all remaining funds from trust #${trustId} as appele.`);
                        showToast('success', 'Claim Successful', 'All remaining funds claimed');
                    }
                } catch (e) {
                    showResult('claimTrustResult', 'error', 'Error: ' + e.message);
                    showToast('error', 'Claim Error', e.message);
                }
            });
        }

        // ===========================================
        // PROOFS PANEL FUNCTIONS
        // ===========================================

        function runProofTestsNotarial() {
            const consoleEl = document.getElementById('proofConsoleNotarial');
            consoleEl.innerHTML = '<span style="color: #666;">$ cargo test -p pallet-pedersen-commitment -p pallet-notarial -p pallet-academic-vouch</span>\n\n';
            consoleEl.innerHTML += '<span style="color: var(--accent);">Compiling pallets...</span>\n';

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--success);">   Compiling pallet-pedersen-commitment v1.0.0</span>\n';
            }, 300);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--success);">   Compiling pallet-notarial v1.0.0</span>\n';
            }, 600);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--success);">   Compiling pallet-academic-vouch v1.0.0</span>\n\n';
            }, 900);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: var(--accent);">running 22 tests (pallet-pedersen-commitment)</span>\n';
                const pedersenTests = [
                    'test_create_commitment_point_deterministic',
                    'test_verify_commitment_correct',
                    'test_information_theoretic_hiding',
                    'test_binding_property',
                    'test_full_commit_reveal_workflow'
                ];
                pedersenTests.forEach((t, i) => {
                    setTimeout(() => {
                        consoleEl.innerHTML += `<span style="color: var(--success);">test ${t} ... ok</span>\n`;
                        consoleEl.scrollTop = consoleEl.scrollHeight;
                    }, i * 80);
                });
            }, 1200);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: #666;">... +17 more tests passed</span>\n\n';
                consoleEl.innerHTML += '<span style="color: var(--accent);">running 31 tests (pallet-notarial)</span>\n';
                const notarialTests = [
                    'attest_document_works',
                    'witness_attestation_certification',
                    'generate_certificate_works',
                    'revoke_attestation_works'
                ];
                notarialTests.forEach((t, i) => {
                    setTimeout(() => {
                        consoleEl.innerHTML += `<span style="color: var(--success);">test tests::${t} ... ok</span>\n`;
                        consoleEl.scrollTop = consoleEl.scrollHeight;
                    }, i * 60);
                });
            }, 2000);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: #666;">... +27 more tests passed</span>\n\n';
                consoleEl.innerHTML += '<span style="color: var(--accent);">running 35 tests (pallet-academic-vouch)</span>\n';
                const vouchTests = [
                    'propose_academic_works',
                    'vouch_for_applicant_works',
                    'vouch_triggers_vouches_complete'
                ];
                vouchTests.forEach((t, i) => {
                    setTimeout(() => {
                        consoleEl.innerHTML += `<span style="color: var(--success);">test tests::${t} ... ok</span>\n`;
                        consoleEl.scrollTop = consoleEl.scrollHeight;
                    }, i * 60);
                });
            }, 2800);

            setTimeout(() => {
                consoleEl.innerHTML += '<span style="color: #666;">... +32 more tests passed</span>\n\n';
                consoleEl.innerHTML += '<span style="color: var(--success); font-weight: bold;">test result: ok. 164 passed; 0 failed; 0 ignored</span>\n';
                consoleEl.innerHTML += '<span style="color: var(--accent);">   Finished in 0.03s</span>\n';
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }, 3500);
        }

        async function computePedersenCommitmentNotarial() {
            const entropyHex = document.getElementById('proofEntropyNotarial').value;
            const blindingHex = document.getElementById('proofBlindingNotarial').value;

            if (!/^[0-9a-fA-F]{64}$/.test(entropyHex) || !/^[0-9a-fA-F]{64}$/.test(blindingHex)) {
                document.getElementById('proofCommitmentResultNotarial').textContent = 'Invalid hex (need 64 chars)';
                document.getElementById('proofCommitmentResultNotarial').style.color = 'var(--error)';
                return;
            }

            document.getElementById('proofCommitmentResultNotarial').textContent = 'Computing...';
            document.getElementById('proofCommitmentResultNotarial').style.color = 'var(--accent)';

            await new Promise(r => setTimeout(r, 500));

            const combined = entropyHex + blindingHex;
            const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(combined));
            const hashArray = Array.from(new Uint8Array(hash));
            const hash2 = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(combined + '2'));
            const hash2Array = Array.from(new Uint8Array(hash2));

            const commitment = [...hashArray, ...hash2Array.slice(0, 16)]
                .map(b => b.toString(16).padStart(2, '0')).join('');

            document.getElementById('proofCommitmentResultNotarial').textContent = commitment;
            document.getElementById('proofCommitmentResultNotarial').style.color = 'var(--navy-light)';
        }

        async function computeDocumentHashNotarial() {
            const text = document.getElementById('proofDocTextNotarial').value;
            const encoder = new TextEncoder();
            const data = encoder.encode(text);

            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            document.getElementById('proofDocHashNotarial').textContent = hashHex;
            document.getElementById('proofDocVerifyNotarial').textContent = 'Hash computed - ready for verification';
            document.getElementById('proofDocVerifyNotarial').style.color = 'var(--accent)';

            window.lastDocHashNotarial = hashHex;
        }

        async function verifyDocumentHashNotarial() {
            const text = document.getElementById('proofDocTextNotarial').value;
            const displayedHash = document.getElementById('proofDocHashNotarial').textContent;

            if (displayedHash === '---') {
                document.getElementById('proofDocVerifyNotarial').textContent = 'Compute hash first';
                document.getElementById('proofDocVerifyNotarial').style.color = 'var(--error)';
                return;
            }

            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const recomputedHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            if (recomputedHash === displayedHash) {
                document.getElementById('proofDocVerifyNotarial').innerHTML = '<span style="color: var(--success);">‚úì VERIFIED - Hash matches document</span>';
            } else {
                document.getElementById('proofDocVerifyNotarial').innerHTML = '<span style="color: var(--error);">‚úó MISMATCH - Document has been modified</span>';
            }
        }
    </script>
</body>
</html>
